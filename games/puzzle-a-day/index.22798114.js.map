{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-a6b8c32907e4aa56.js","src/engine/units/dir.ts","src/engine/units/vec.ts","src/engine/input/input.ts","src/engine/logger.ts","src/engine/settings.ts","src/engine/globals/window.ts","src/engine/color.ts","src/engine/globals/document.ts","src/engine/canvas.ts","src/engine/units/rect.ts","src/engine/ui/panel.ts","src/engine/units/primitives.ts","src/engine/renderer/renderer.ts","src/engine/maths.ts","src/engine/debugger.ts","src/engine/collision.ts","src/engine/camera/camera.ts","src/engine/sprites/sprites.ts","src/engine/events/EventManager.ts","src/engine/ui/ui.ts","src/engine/notifications/notifications.ts","src/engine/scenes/sceneManager.ts","src/engine/global.ts","src/engine/objects/gameObject.ts","src/engine/grid.ts","src/engine/units/matrix.ts","src/engine/objects/displayObject.ts","src/puzzle-a-day/ui/UIObject.ts","src/engine/objects/helperts.ts","src/engine/id/id.ts","src/engine/objects/spriteObject.ts","src/puzzle-a-day/Cursor.ts","src/puzzle-a-day/Piece.ts","src/puzzle-a-day/PieceManager.ts","src/puzzle-a-day/pieces/piece-factory.ts","src/puzzle-a-day/game-state/GameState.ts","src/puzzle-a-day/global.ts","src/engine/scenes/scene.ts","src/engine/cursor.ts","src/engine/runtime.ts","node_modules/@parcel/runtime-js/lib/runtime-403a5e3f8d0c484f.js","src/puzzle-a-day/resources/sprites.json","src/puzzle-a-day/board/Board.ts","src/puzzle-a-day/calendar/CalendarDate.ts","src/puzzle-a-day/calendar/CalendarNavigation.ts","src/puzzle-a-day/calendar/calendar.ts","src/engine/renderer/utils.ts","src/puzzle-a-day/index.ts","src/engine/sprites/sprite-fx.ts","src/puzzle-a-day/game-state/default-state.ts"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"bpvlM\\\":\\\"index.22798114.js\\\",\\\"1vJCw\\\":\\\"sprites.7bbc2069.png\\\"}\"));","export const NORTH_REF = { x: 0, y: -1 };\nexport const EAST_REF = { x: 0, y: -1 };\nexport const SOUTH_REF = { x: 0, y: -1 };\nexport const WEST_REF = { x: 0, y: -1 };\n","import { EAST_REF, NORTH_REF, SOUTH_REF, WEST_REF } from \"./dir\";\n\nexport function vec(x = 0, y = 0): Vec {\n  return new Vec(x, y);\n}\n\nexport enum Direction {\n  North,\n  East,\n  South,\n  West,\n}\n\nexport class Vec {\n  constructor(public x = 0, public y = 0) {}\n\n  public static from({ x, y }: { x: number; y: number }): Vec {\n    return vec(x, y);\n  }\n\n  public static north(): Vec {\n    return Vec.from(NORTH_REF);\n  }\n\n  public static east(): Vec {\n    return Vec.from(EAST_REF);\n  }\n\n  public static south(): Vec {\n    return Vec.from(SOUTH_REF);\n  }\n\n  public static west(): Vec {\n    return Vec.from(WEST_REF);\n  }\n\n  public toString(fixed = 0): string {\n    return `{ ${this.x.toFixed(fixed)},${this.y.toFixed(fixed)} }`;\n  }\n\n  public equalsv(v: Vec): boolean {\n    return this.equals(v.x, v.y);\n  }\n\n  public equals(x: number, y: number): boolean {\n    return this.x === x && this.y === y;\n  }\n\n  public add(x: number, y = x): Vec {\n    return vec(this.x + x, this.y + y);\n  }\n\n  public addv(v: Vec): Vec {\n    return vec(this.x + v.x, this.y + v.y);\n  }\n\n  public clone(): Vec {\n    return vec(this.x, this.y);\n  }\n\n  public sub(x: number, y = x): Vec {\n    return vec(this.x - x, this.y - y);\n  }\n\n  public subv(v: Vec): Vec {\n    return vec(this.x - v.x, this.y - v.y);\n  }\n\n  public divide(x: number, y = x): Vec {\n    const sx = x === 0 ? 0 : this.x / x;\n    const sy = y === 0 ? 0 : this.y / y;\n\n    return vec(sx, sy);\n  }\n\n  public multiply(x: number, y = x): Vec {\n    return vec(this.x * x, this.y * y);\n  }\n\n  public round(): Vec {\n    return vec(Math.round(this.x), Math.round(this.y));\n  }\n\n  public mag(): number {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  public normalize(): Vec {\n    return this.divide(this.mag());\n  }\n\n  public distance(p: Vec): number {\n    return Math.abs(\n      Math.sqrt(\n        (this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y)\n      )\n    );\n  }\n\n  public dir(dest: Vec): Vec {\n    return dest.subv(this).normalize().round();\n  }\n\n  public static lerp(start: Vec, end: Vec, progress: number): Vec {\n    const axis = (s: number, e: number) => (1 - progress) * s + progress * e;\n    return vec(axis(start.x, end.x), axis(start.y, end.y));\n  }\n\n  public static deserialiseDirection(dir: Vec): Direction {\n    if (dir.equalsv(Vec.north())) {\n      return Direction.North;\n    }\n    if (dir.equalsv(Vec.east())) {\n      return Direction.East;\n    }\n    if (dir.equalsv(Vec.south())) {\n      return Direction.South;\n    }\n    if (dir.equalsv(Vec.west())) {\n      return Direction.West;\n    }\n\n    throw new Error(\"unable to deserialise direction: \" + dir.toString());\n  }\n\n  public static isMatchingList(a: Vec[], b: Vec[]): boolean {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (const p of a) {\n      if (!b.find((v) => p.equalsv(v))) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n","import { vec, Vec } from \"../units/vec\";\nimport { Camera } from \"../camera/camera\";\nimport { debug } from \"../global\";\nimport { STAGE_HEIGHT, STAGE_WIDTH } from \"../settings\";\n\nexport enum PointerState {\n  Idle,\n  Primary,\n  Secondary,\n}\n\nexport enum KeyInput {\n  Rotate = \"r\",\n  Flip = \"f\",\n  Save = \"s\",\n  Load = \"l\",\n}\n\nclass Pointer {\n  public state = PointerState.Idle;\n\n  public isDown = false;\n  public downThisFrame = false;\n\n  constructor(private pos = vec(), private camera: Camera) {}\n\n  public setScreenPos(vec: Vec): void {\n    this.pos = vec;\n  }\n\n  public getWorldPos(): Vec {\n    return this.pos.subv(this.camera.getOffset());\n  }\n\n  public getScreenPos(): Vec {\n    return this.pos;\n  }\n}\n\nexport function createInputManager(\n  canvas: HTMLCanvasElement,\n  camera: Camera\n): InputManager {\n  const r = canvas.getBoundingClientRect();\n  return new InputManager(vec(r.left, r.top), camera);\n}\n\nclass InputManager {\n  public readonly pointer: Pointer;\n  private keyDownThisFrame: KeyInput | null = null;\n\n  private keyWasDown: KeyInput | null = null;\n  private pointerWasDown = false;\n\n  constructor(public stageOffset: Vec, private camera: Camera) {\n    this.pointer = new Pointer(vec(), this.camera);\n  }\n\n  public start(): void {\n    document.addEventListener(\"pointermove\", (event) => {\n      const client = vec(event.clientX, event.clientY);\n      this.pointer.setScreenPos(client.subv(this.stageOffset));\n    });\n\n    document.addEventListener(\"pointerdown\", (event) => {\n      event.preventDefault();\n      this.pointer.isDown = true;\n      this.pointer.state =\n        event.which === 1 ? PointerState.Primary : PointerState.Secondary;\n    });\n\n    document.addEventListener(\"pointerup\", (event) => {\n      this.pointer.state = PointerState.Idle;\n      this.pointer.isDown = false;\n      this.pointerWasDown = false;\n    });\n\n    document.addEventListener(\"keydown\", (event) => {\n      const key = event.key as KeyInput;\n      if (!Object.values(KeyInput).includes(key)) {\n        return;\n      }\n\n      if (this.keyDownThisFrame !== key) {\n        this.keyDownThisFrame = key;\n      }\n    });\n  }\n\n  public update(): void {\n    this.pointer.downThisFrame = false;\n\n    if (this.pointer.isDown) {\n      if (!this.pointerWasDown) {\n        this.pointer.downThisFrame = true;\n        this.pointerWasDown = true;\n      }\n    }\n\n    if (!this.keyWasDown) {\n      this.keyWasDown = this.keyDownThisFrame;\n    } else {\n      this.keyDownThisFrame = null;\n      this.keyWasDown = null;\n    }\n  }\n\n  public getKeyDownThisFrame(): KeyInput | null {\n    return this.keyDownThisFrame;\n  }\n\n  public isPointerDownThisFrame(): boolean {\n    return this.pointer.downThisFrame;\n  }\n\n  public isPointerDown(): boolean {\n    return this.pointer.isDown;\n  }\n\n  public debug(): void {\n    debug.print(\n      \"pointer\",\n      `S: ${this.pointer.getScreenPos()} w: ${this.pointer.getWorldPos()}`\n    );\n    debug.print(\"key\", this.keyDownThisFrame ?? \"null\");\n    debug.print(\"pointer\", this.isPointerDownThisFrame());\n  }\n}\n","interface Transport {\n  log: (s: string) => void;\n}\n\nexport function createLogger(): Logger {\n  return new Logger();\n}\n\nexport class Logger {\n  private readonly fmt = \"[%s]: %s\";\n  private transport: Transport = console;\n\n  public warn(msg: string): void {\n    this.write(msg);\n  }\n\n  private write(msg: string): void {\n    const now = new Date();\n    this.transport.log(this.format(this.fmt, now.toISOString(), msg));\n  }\n\n  private format(str: string, ...values: string[]): string {\n    let f = str;\n    for (const v of values) {\n      f = f.replace(\"%s\", v);\n    }\n    return f;\n  }\n}\n","// ENGINE\n// export const STAGE_WIDTH = 900;\nimport { getWindowHeight, getWindowWidth } from \"./globals/window\";\n\nexport const STAGE_WIDTH = getWindowWidth() - 128;\n// export const STAGE_HEIGHT = 600;\nexport const STAGE_HEIGHT = getWindowHeight() - 128;\nexport const FPS = 60;\nexport const SPRITE_SCALE = 2;\n\n// SPRITES\nexport const SPRITE_SIZE = 32;\nexport const SPRITES_ENABLED = true;\n\n// GRID\nexport const GRID_WIDTH = 5;\nexport const GRID_HEIGHT = 5;\nexport const GRID_UNIT = (SPRITE_SIZE / 2) * SPRITE_SCALE;\n\n// UI\nexport const UI_ENABLED = false;\n\n// DEBUG\nexport const DEBUG = true;\nexport const DEBUG_SCENE = true;\nexport const DEBUG_STATE = false;\nexport const DEBUG_CAMERA = false;\nexport const DEBUG_RESOURCES = false;\nexport const DEBUG_SPRITES = false;\nexport const DEBUG_GRID = false;\nexport const DEBUG_DISPLAY_OBJS = false;\nexport const DEBUG_COLLIDERS = false;\nexport const DEBUG_COLLISION = false;\n\nexport const PAUSE = false;\n\n// GAME SPECIFIC\n// TODO: move this to another file\nexport const DRAW_PIECES = true;\nexport const DEBUG_BOARD = false;\nexport const DEBUG_PIECES = false;\nexport const DEBUG_PIECE_MANAGER = false;\n","export function getWindowWidth(): number {\n  return window.innerWidth;\n}\n\nexport function getWindowHeight(): number {\n  return window.innerHeight;\n}\n","export function white(a = 1): string {\n  return new Color(255, 255, 255, a).toString();\n}\n\nexport function red(a = 1): string {\n  return new Color(255, 0, 0, a).toString();\n}\n\nexport function green(a = 1): string {\n  return new Color(0, 255, 0, a).toString();\n}\n\nexport function blue(a = 1): string {\n  return new Color(0, 0, 255, a).toString();\n}\n\nexport interface SerialisedColor {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\n\nexport class Color {\n  constructor(public r = 255, public g = 255, public b = 255, public a = 1) {}\n\n  public static from(pixel: number[]): Color {\n    return new Color(pixel[0], pixel[1], pixel[2], pixel[3]);\n  }\n\n  public static empty(): Color {\n    return new Color(0, 0, 0, 0);\n  }\n\n  public static black(): Color {\n    return new Color(0, 0, 0, 1);\n  }\n\n  public static red(a = 1): Color {\n    return new Color(255, 0, 0, a);\n  }\n\n  public static green(a = 1): Color {\n    return new Color(0, 255, 0, a);\n  }\n\n  public static blue(): Color {\n    return new Color(0, 0, 255, 1);\n  }\n\n  public static white(a = 1): Color {\n    return new Color(255, 255, 255, a);\n  }\n\n  public static magenta(a = 1): Color {\n    return new Color(255, 0, 255, a);\n  }\n\n  public toString(): string {\n    return `rgba(${this.r},${this.g},${this.b},${this.a})`;\n  }\n\n  public equals(c: Color): boolean {\n    return c.r === this.r && c.g === this.g && c.b === this.b && c.a === this.a;\n  }\n\n  public serialise(): SerialisedColor {\n    return { r: this.r, g: this.g, b: this.b, a: this.a };\n  }\n}\n","export function getDocument(): Document {\n  return document;\n}\n","import { getDocument } from \"./globals/document\";\n\nexport type CTX = CanvasRenderingContext2D;\n\nexport interface Canvas {\n  el: HTMLCanvasElement;\n  ctx: CTX;\n}\n\nexport function getCanvas(\n  id: string = \"stage\",\n  settings: CanvasRenderingContext2DSettings = {}\n): Canvas {\n  const c = getDocument().getElementById(id) as HTMLCanvasElement;\n  if (!c) {\n    throw new Error(`Could not find #${id} element`);\n  }\n  const ctx = c.getContext(\"2d\", settings);\n  if (!ctx) {\n    throw new Error(\"Could not get 2d context\");\n  }\n  return { el: c, ctx };\n}\n\nexport function createCanvas(\n  width: number,\n  height: number,\n  settings: CanvasRenderingContext2DSettings = {}\n): Canvas {\n  const cvs = getDocument().createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\", settings);\n\n  if (!ctx) {\n    throw new Error(\"Could not get 2d context\");\n  }\n\n  cvs.width = width;\n  cvs.height = height;\n  ctx.imageSmoothingEnabled = false;\n\n  return { el: cvs, ctx };\n}\n","import { Vec, vec } from \"./vec\";\n\nexport function rect(x: number, y: number, w: number, h: number): Rect {\n  return new Rect(x, y, w, h);\n}\n\nexport class Rect {\n  public pos: Vec;\n  public width: number;\n  public height: number;\n\n  public get x() {\n    return this.pos.x;\n  }\n\n  public get y() {\n    return this.pos.y;\n  }\n\n  public get w() {\n    return this.width;\n  }\n\n  public get h() {\n    return this.height;\n  }\n\n  constructor(x: number, y: number, w: number, h: number) {\n    this.pos = vec(x, y);\n    this.width = w;\n    this.height = h;\n  }\n\n  public contains(v: Vec): boolean {\n    if (v.x < this.pos.x || v.x > this.pos.x + (this.width - 1)) {\n      return false;\n    }\n\n    if (v.y < this.pos.y || v.y > this.pos.y + (this.height - 1)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public multiply(n: number): Rect {\n    return rect(\n      this.pos.x * n,\n      this.pos.y * n,\n      this.width * n,\n      this.height * n\n    );\n  }\n\n  public toString(): string {\n    return `{x:${this.pos.x},y:${this.pos.y},w:${this.width},h:${this.height}}`;\n  }\n\n  public addv(p: Vec): Rect {\n    const n = this.pos.addv(p);\n    return rect(n.x, n.y, this.width, this.height);\n  }\n\n  public static getRect(o: { pos: Vec; width: number; height: number }): Rect {\n    return new Rect(o.pos.x, o.pos.y, o.width, o.height);\n  }\n}\n","import { vec, Vec } from \"../units/vec\";\nimport { renderer } from \"../global\";\nimport { Color } from \"../color\";\nimport { STAGE_HEIGHT, STAGE_WIDTH } from \"../settings\";\nimport { rect, Rect } from \"../units/rect\";\n\nexport enum Position {\n  TopRight,\n  BottomRight,\n}\n\nexport enum Size {\n  Small,\n}\n\nexport const PADDING = 16;\nexport const FONT_SIZE = 16;\n\nexport function createPanel(\n  content: string,\n  pos: Position,\n  size: Size = Size.Small\n): Panel {\n  return new Panel(content, pos, size);\n}\n\nexport class Panel {\n  constructor(\n    private content: string,\n    public pos: Position,\n    public size: Size\n  ) {}\n\n  protected getRect(): Rect {\n    const p = this.getPos();\n    const [w, h] = this.getWidthAndHeight();\n    return rect(p.x, p.y, w, h);\n  }\n\n  private getPos(): Vec {\n    const [w, h] = this.getWidthAndHeight();\n    switch (this.pos) {\n      case Position.TopRight:\n        return vec(STAGE_WIDTH / 2, PADDING);\n      case Position.BottomRight:\n        return vec(STAGE_WIDTH / 2, STAGE_HEIGHT - h - PADDING);\n      default:\n        throw new Error(`Cannot draw panel with position: ${this.pos}`);\n    }\n  }\n\n  private getWidthAndHeight(): [width: number, height: number] {\n    switch (this.size) {\n      case Size.Small:\n        return [STAGE_WIDTH / 2 - PADDING, STAGE_HEIGHT / 4 - PADDING];\n      default:\n        throw new Error(`Cannot draw panel with size: ${this.size}`);\n    }\n  }\n\n  public setContent(content: string): void {\n    this.content = content;\n  }\n\n  public draw(): void {\n    const [width, height] = this.getWidthAndHeight();\n    const pos = this.getPos();\n    renderer.fillRect(pos, width, height, Color.black(), vec(), \"ui\");\n    renderer.fillText(\n      this.content,\n      pos.add(PADDING, PADDING / 2 + FONT_SIZE),\n      Color.white(),\n      width - PADDING * 2,\n      \"ui\"\n    );\n  }\n}\n","export class SafeMap<T, K> {\n  private map: Map<T, K>;\n\n  constructor(entries: [T, K][] = []) {\n    this.map = new Map(entries);\n  }\n\n  public entries(): IterableIterator<[T, K]> {\n    return this.map.entries();\n  }\n\n  public values(): IterableIterator<K> {\n    return this.map.values();\n  }\n\n  public set(k: T, v: K): void {\n    this.map.set(k, v);\n  }\n\n  public get(k: T): K {\n    if (!this.map.has(k)) {\n      throw new Error(`Attempted to access unset key \"${k}\" in safe map!`);\n    }\n    return this.map.get(k)!;\n  }\n}\n","import { vec, Vec } from \"../units/vec\";\nimport {\n  DEBUG,\n  DEBUG_SPRITES,\n  GRID_UNIT,\n  SPRITES_ENABLED,\n  STAGE_HEIGHT,\n  STAGE_WIDTH,\n} from \"../settings\";\nimport { Color } from \"../color\";\nimport { debug, sprites } from \"../global\";\nimport { CTX, getCanvas } from \"../canvas\";\nimport * as fx from \"../fx\";\nimport { FONT_SIZE } from \"../ui/panel\";\nimport { rect, Rect } from \"../units/rect\";\nimport { highlight } from \"../fx\";\nimport { SafeMap } from \"../units/primitives\";\n\ninterface DrawCall {\n  draw: (offset: Vec) => void;\n  y: number;\n  z: number;\n}\n\nexport function createRenderer(layers: SafeMap<string, number>): Renderer {\n  const c = getCanvas();\n\n  c.ctx.fillStyle = Color.black().toString();\n  c.el.width = STAGE_WIDTH;\n  c.el.height = STAGE_HEIGHT;\n\n  const zLayers = new SafeMap<string, number>();\n  zLayers.set(\"default\", 100);\n  zLayers.set(\"debug\", 450);\n  zLayers.set(\"ui\", 500);\n  zLayers.set(\"cursor\", 600);\n\n  for (const [key, val] of layers.entries()) {\n    zLayers.set(key, val);\n  }\n\n  return new Renderer(c.el, c.ctx, zLayers);\n}\n\nexport class Renderer {\n  public stage: Rect;\n  private queue: Set<DrawCall> = new Set();\n\n  constructor(\n    public canvas: HTMLCanvasElement,\n    public ctx: CTX,\n    private layers: SafeMap<string, number>\n  ) {\n    const bcr = this.canvas.getBoundingClientRect();\n    // TODO: refresh this if the window changes\n    this.stage = rect(0, 0, bcr.width, bcr.height);\n    this.ctx.font = `${FONT_SIZE}px monospace`;\n  }\n\n  public clear() {\n    this.ctx.clearRect(0, 0, STAGE_WIDTH, STAGE_HEIGHT);\n    this.ctx.save();\n    this.ctx.fillStyle = new Color(21, 50, 67).toString();\n    this.ctx.fillRect(0, 0, STAGE_WIDTH, STAGE_HEIGHT);\n    this.ctx.restore();\n  }\n\n  private getWorldPos(pos: Vec, camOffset: Vec, layer = \"default\"): Vec {\n    switch (layer) {\n      case \"ui\":\n        return pos.clone();\n      default:\n        return pos.addv(camOffset);\n    }\n  }\n\n  public fillRect(\n    pos: Vec,\n    width: number,\n    height: number,\n    color: Color,\n    originOffset = vec(),\n    layer: string = \"defaultl\"\n  ): void {\n    this.queue.add({\n      draw: (offset) => {\n        const wp = this.getWorldPos(pos, offset, layer).addv(originOffset);\n        this.ctx.save();\n        this.ctx.fillStyle = color.toString();\n        this.ctx.fillRect(wp.x, wp.y, width, height);\n        this.ctx.restore();\n      },\n      z: this.layers.get(layer),\n      y: pos.y,\n    });\n  }\n\n  public drawISoRect(\n    pos: Vec,\n    width: number,\n    height: number,\n    color: Color,\n    fill = true,\n    originOffset = vec(0, 0),\n    strokeWidth = 4,\n    layer = \"default\"\n  ): void {\n    this.queue.add({\n      draw: (offset) => {\n        const wp = this.getWorldPos(pos, offset, layer).addv(originOffset);\n        this.ctx.save();\n        this.ctx.beginPath();\n        if (fill) {\n          this.ctx.fillStyle = color.toString();\n        } else {\n          this.ctx.strokeStyle = color.toString();\n          this.ctx.lineWidth = strokeWidth;\n        }\n\n        this.ctx.moveTo(wp.x, wp.y);\n        this.ctx.lineTo(wp.x + width, wp.y + height / 2);\n        this.ctx.lineTo(wp.x, wp.y + height);\n        this.ctx.lineTo(wp.x - width, wp.y + height / 2);\n\n        this.ctx.closePath();\n        if (fill) {\n          this.ctx.fill();\n        } else {\n          this.ctx.stroke();\n        }\n        this.ctx.restore();\n      },\n      z: this.layers.get(layer),\n      y: pos.y,\n    });\n  }\n\n  public strokeRect(\n    pos: Vec,\n    width: number,\n    height: number,\n    color: string,\n    layer = \"default\"\n  ): void {\n    this.queue.add({\n      draw: (offset) => {\n        const wp = this.getWorldPos(pos, offset, layer);\n        this.ctx.save();\n        this.ctx.strokeStyle = color;\n        this.ctx.strokeRect(wp.x, wp.y, width, height);\n        this.ctx.restore();\n      },\n      z: this.layers.get(layer),\n      y: pos.y,\n    });\n  }\n\n  public fillText(\n    text: string,\n    pos: Vec,\n    color: Color,\n    maxWidth?: number,\n    layer = \"default\"\n  ): void {\n    this.queue.add({\n      draw: (offset) => {\n        const wp = this.getWorldPos(pos, offset, layer);\n        this.ctx.save();\n        this.ctx.fillStyle = color.toString();\n        this.ctx.font = `${FONT_SIZE}px monospace`;\n\n        if (layer === \"ui\") {\n          this.ctx.font = `${FONT_SIZE}px monospace`;\n        }\n\n        let newlineOffset = 0;\n        for (const line of text.split(\"\\n\")) {\n          this.ctx.fillText(line, wp.x, wp.y + newlineOffset, maxWidth);\n          newlineOffset += FONT_SIZE;\n        }\n\n        this.ctx.restore();\n      },\n      z: this.layers.get(layer),\n      y: pos.y,\n    });\n  }\n\n  public path(\n    points: Vec[],\n    color: Color,\n    lineWidth: number,\n    layer = \"default\"\n  ): void {\n    this.queue.add({\n      draw: (offset) => {\n        this.ctx.save();\n        this.ctx.beginPath();\n        this.ctx.strokeStyle = color.toString();\n        this.ctx.lineWidth = lineWidth;\n\n        for (let i = 0; i < points.length; i++) {\n          const { x, y } = points[i].addv(offset);\n          if (i === 0) {\n            this.ctx.moveTo(x, y);\n          } else {\n            this.ctx.lineTo(x, y);\n          }\n        }\n\n        for (const p of points.slice(1)) {\n          this.ctx.lineTo(p.addv(offset).x, p.addv(offset).y);\n        }\n\n        this.ctx.closePath();\n        this.ctx.stroke();\n        this.ctx.restore();\n      },\n      z: this.layers.get(layer),\n      y: points[0].y,\n    });\n  }\n\n  public renderSprite(\n    key: string,\n    pos: Vec,\n    tint = Color.empty(),\n    alpha = 1,\n    layer = \"default\",\n    frameIndex = 0\n  ): void {\n    if (!SPRITES_ENABLED) {\n      return;\n    }\n\n    this.queue.add({\n      draw: (offset) => {\n        const sprite = sprites.get(key);\n        const frame = sprite.getFrame(frameIndex);\n        const wp = this.getWorldPos(pos, offset, layer);\n\n        if (!sprite) {\n          this.ctx.fillStyle = Color.magenta().toString();\n          this.ctx.save();\n          this.ctx.fillRect(wp.x, wp.y, GRID_UNIT, GRID_UNIT);\n          this.ctx.restore();\n          return;\n        }\n\n        const sp = wp.addv(sprite.getOffset(frameIndex));\n        const width = sprite.getWidth();\n        const height = sprite.getHeight();\n\n        if (DEBUG_SPRITES) {\n          this.ctx.strokeStyle = Color.red().toString();\n          this.ctx.fillRect(wp.x, wp.y, 10, 10);\n          this.ctx.strokeRect(sp.x, sp.y, width, height);\n        }\n\n        let cvs = frame.img;\n        if (alpha) {\n          this.ctx.globalAlpha = alpha;\n        }\n\n        this.ctx.save();\n        this.ctx.drawImage(cvs, 0, 0, width, height, sp.x, sp.y, width, height);\n        this.ctx.restore();\n      },\n      y: pos.y,\n      z: this.layers.get(layer),\n    });\n  }\n\n  public draw(offset: Vec): void {\n    const layers: Map<number, DrawCall[]> = new Map();\n    for (const call of this.queue) {\n      const q = layers.get(call.z) ?? [];\n      layers.set(call.z, [...q, call]);\n    }\n\n    for (const calls of layers.values()) {\n      calls.sort((a, b) => {\n        return a.y - b.y;\n      });\n    }\n\n    const sortedLayers = [...layers.keys()].sort((a, b) => a - b);\n\n    for (const layer of sortedLayers) {\n      const calls = layers.get(layer)!;\n      for (const call of calls) {\n        this.ctx.save();\n        call.draw(offset);\n        this.ctx.restore();\n      }\n    }\n\n    this.queue.clear();\n  }\n\n  // TODO: culling...\n  //  1. create rect from stage\n  //  2. implement rect.contains(p)\n\n  // Can the renderer draw a point, i.e. is it in bounds of the stage\n  public willDraw(p: Vec): boolean {\n    return this.stage.contains(p);\n  }\n}\n","import { vec, Vec } from \"./units/vec\";\n\nexport function randInt(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\nexport function randVec(min: Vec, max: Vec): Vec {\n  return vec(randInt(min.x, max.x), randInt(min.y, max.y));\n}\n\nexport function randRange(n: number, v: number): number {\n  const variance = (n * v) / 2;\n  const r = randInt(n - variance, n + variance);\n  return r;\n}\n\nexport function delta(n: number, done: () => void): (d: number) => void {\n  let t = 0;\n  return (d: number) => {\n    t += d;\n    if (t < n) return;\n    t = 0;\n    done();\n  };\n}\n\nexport function clamp(n: number, min: number, max: number): number {\n  return n < min ? min : n > max ? max : n;\n}\n\nexport function mean(v: number[]): number {\n  if (!v.length) {\n    return 0;\n  }\n\n  return (\n    v.reduce((acc, v) => {\n      return acc + v;\n    }, 0) / v.length\n  );\n}\n\nexport function max(list: number[]): number {\n  let m = 0;\n  for (const n of list) {\n    m = n > m ? n : m;\n  }\n  return m;\n}\n\nexport function wrap(n: any, min: any, max: number): number {\n  const range = max - min + 1;\n  const mod = (n - min) % range;\n  const pMod = mod < 0 ? mod + range : mod;\n  return pMod + min;\n}\n","import { green } from \"./color\";\nimport { vec } from \"./units/vec\";\nimport { CTX } from \"./canvas\";\nimport { DEBUG } from \"./settings\";\nimport { mean } from \"./maths\";\n\nconst FONT_SIZE = 12;\n\nexport function createDebugger(ctx: CTX): Debugger {\n  return new Debugger(ctx);\n}\n\ninterface DeferDraw {\n  fn: () => void;\n}\n\ninterface DebugValue {\n  toString(): string;\n}\n\ninterface SampleCache {\n  size: number;\n  values: number[];\n  lastSampleValue: number;\n}\n\nclass Debugger {\n  private y = 0;\n  private padding = vec(16, 28);\n  private size = FONT_SIZE;\n  private style = `${this.size}px monospace`;\n\n  private queue = new Set<DeferDraw>();\n  private sampleCache = new Map<string, SampleCache>();\n\n  constructor(private ctx: CTX) {}\n\n  private enqueue(dd: DeferDraw): void {\n    this.queue.add(dd);\n  }\n\n  public print(\n    label: string,\n    value: DebugValue,\n    color: string = green()\n  ): void {\n    this.enqueue({\n      fn: () => {\n        this.ctx.save();\n        this.ctx.fillStyle = color;\n        this.ctx.fillText(\n          `${label}: ${value.toString()}`,\n          this.padding.x,\n          this.padding.y + this.y\n        );\n        this.ctx.restore();\n      },\n    });\n  }\n\n  public sample(\n    label: string,\n    value: number,\n    size: number,\n    transform = (value: number) => value.toString(),\n    color: string = green()\n  ): void {\n    if (size <= 1) {\n      throw new Error(\"Cannot sample 1 value!\");\n    }\n\n    const cache = this.sampleCache.get(label);\n    if (!cache) {\n      this.sampleCache.set(label, {\n        size: size,\n        values: [value],\n        lastSampleValue: 0,\n      });\n      return;\n    }\n\n    let values = [...cache.values, value];\n    let lastSampleValue = cache.lastSampleValue;\n    if (values.length === cache.size) {\n      values = [];\n      lastSampleValue = mean(cache.values);\n    }\n\n    this.print(label, transform(lastSampleValue), color);\n\n    this.sampleCache.set(label, {\n      size,\n      values,\n      lastSampleValue,\n    });\n  }\n\n  public draw(): void {\n    if (!DEBUG) {\n      return;\n    }\n\n    for (const { fn } of this.queue) {\n      this.ctx.save();\n      this.ctx.font = this.style;\n      fn();\n      this.y += this.size;\n      this.ctx.restore();\n    }\n    this.queue.clear();\n    this.y = 0;\n  }\n}\n","import { Collider } from \"./collider\";\nimport { Vec } from \"./units/vec\";\nimport { CTX, getCanvas } from \"./canvas\";\nimport { camera, renderer, debug } from \"./global\";\nimport { DEBUG_COLLIDERS, DEBUG_COLLISION } from \"./settings\";\nimport { GameObject } from \"./objects/gameObject\";\n\nexport function createCollisionManager(): CollisionManager {\n  return new CollisionManager();\n}\n\nexport class CollisionManager {\n  private colliders = new Set<Collider>();\n  private ctx: CTX;\n  private cache: Uint8ClampedArray | null = null;\n\n  constructor() {\n    const cvs = getCanvas(\"collision\", {\n      willReadFrequently: true,\n    });\n    cvs.el.width = renderer.canvas.width;\n    cvs.el.height = renderer.canvas.height;\n    this.ctx = cvs.ctx;\n  }\n\n  public addCollider(c: Collider): void {\n    this.colliders.add(c);\n  }\n\n  public removeCollider(c: Collider): void {\n    this.colliders.delete(c);\n  }\n\n  public getObjAt(p: Vec): GameObject[] {\n    const start = Date.now();\n    const offset = camera.getOffset();\n    const objs: GameObject[] = [];\n\n    for (const c of this.colliders) {\n      if (!c.obj) {\n        continue;\n      }\n\n      /**\n       * Abstract this collision detection....\n       */\n      const path = c.getWorldPath()?.map((p) => p.addv(offset));\n      if (path.every((p) => !renderer.willDraw(p))) {\n        c.disable();\n      }\n\n      if (!c.isEnabled()) {\n        continue;\n      }\n\n      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n\n      this.ctx.beginPath();\n      this.ctx.fillStyle = \"red\";\n      for (let i = 0; i < path.length; i++) {\n        if (i === 0) {\n          this.ctx.moveTo(path[i].x, path[i].y);\n        } else {\n          this.ctx.lineTo(path[i].x, path[i].y);\n        }\n      }\n      this.ctx.fill();\n      this.ctx.closePath();\n\n      // if (!this.cache) {\n      this.cache = this.ctx.getImageData(p.x, p.y, 1, 1).data;\n      // }\n\n      if (this.cache[0] || this.cache[1] || this.cache[2]) {\n        objs.push(c.obj);\n      }\n      this.ctx.fillStyle = \"blue\";\n      this.ctx.fillRect(p.x, p.y, 4, 4);\n    }\n\n    if (DEBUG_COLLISION) {\n      debug.sample(\"COLLISION RESOLVED\", Date.now() - start, 30, (value) => {\n        return value.toFixed(2) + \"ms\";\n      });\n    }\n\n    return objs;\n  }\n\n  public debug() {\n    if (DEBUG_COLLIDERS) {\n      debug.print(\n        \"active colliders\",\n        [...this.colliders].filter((c) => c.isEnabled()).length\n      );\n    }\n  }\n}\n","import { Vec, vec } from \"../units/vec\";\nimport { Renderer } from \"../renderer/renderer\";\nimport { DEBUG_CAMERA, STAGE_HEIGHT, STAGE_WIDTH } from \"../settings\";\nimport { Color } from \"../color\";\nimport { input, renderer } from \"../global\";\nimport { PointerState } from \"../input/input\";\n\nexport function createCamera(renderer: Renderer, pos = vec()): Camera {\n  return new Camera(renderer, pos);\n}\n\nexport class Camera {\n  private pointerAnchor = vec();\n  private posAnchor = vec();\n\n  constructor(private renderer: Renderer, public pos: Vec) {}\n\n  public getOffset(): Vec {\n    return this.pos.add(STAGE_WIDTH / 2, STAGE_HEIGHT / 2);\n  }\n\n  public snapTo(p: Vec): void {\n    this.pos = p;\n  }\n\n  public update(delta: number): void {\n    if (\n      input.isPointerDown() &&\n      input.pointer.state === PointerState.Secondary\n    ) {\n      if (input.isPointerDownThisFrame()) {\n        this.pointerAnchor = input.pointer.getScreenPos();\n        this.posAnchor = this.pos.clone();\n      }\n\n      this.pos = this.posAnchor.addv(\n        input.pointer.getScreenPos().subv(this.pointerAnchor)\n      );\n    }\n  }\n\n  public debug(): void {\n    if (!DEBUG_CAMERA) {\n      return;\n    }\n\n    const { ctx } = renderer;\n    const center = vec(STAGE_WIDTH / 2, STAGE_HEIGHT / 2);\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.strokeStyle = Color.green().toString();\n    ctx.fillStyle = Color.green().toString();\n    ctx.moveTo(center.x, 0);\n    ctx.lineTo(center.x, STAGE_HEIGHT);\n    ctx.moveTo(0, center.y);\n    ctx.lineTo(STAGE_WIDTH, center.y);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.fillText(this.pos.toString(), center.x, center.y);\n    ctx.restore();\n  }\n\n  public draw(): void {\n    this.renderer.draw(this.getOffset());\n  }\n}\n","import { vec, Vec } from \"../units/vec\";\nimport { Canvas, createCanvas, CTX } from \"../canvas\";\nimport { DEBUG_RESOURCES, SPRITE_SCALE } from \"../settings\";\nimport { Color } from \"../color\";\nimport { rect, Rect } from \"../units/rect\";\nimport { SafeMap } from \"../units/primitives\";\n\ninterface SpriteFrame {\n  img: HTMLCanvasElement;\n  offset: Vec;\n\n  width: number;\n\n  height: number;\n}\n\nexport class Sprite {\n  private frames: SpriteFrame[] = [];\n  constructor(private name: string, private width = 0, private height = 0) {}\n\n  public addFrame(frame: SpriteFrame): void {\n    this.frames.push(frame);\n    this.width = Math.max(this.width, frame.width);\n    this.height = Math.max(this.height, frame.height);\n  }\n\n  public getFrames(): SpriteFrame[] {\n    return this.frames;\n  }\n\n  public getFrameLen(): number {\n    return this.frames.length;\n  }\n\n  public getFrame(frame: number): SpriteFrame {\n    if (!this.frames[frame]) {\n      throw new Error(`sprite frame not loaded: \"${frame}\"`);\n    }\n    return this.frames[frame];\n  }\n\n  public getOffset(frame: number): Vec {\n    if (!this.frames[frame]) {\n      throw new Error(`sprite frame not loaded: \"${frame}\"`);\n    }\n    return this.frames[frame].offset;\n  }\n\n  public getWidth(): number {\n    return this.width;\n  }\n\n  public getHeight(): number {\n    return this.height;\n  }\n\n  public getName(): string {\n    return this.name;\n  }\n}\n\ninterface SpriteFrameData {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n  ox: number;\n  oy: number;\n}\n\nexport interface SheetData {\n  [index: string]: {\n    frames: SpriteFrameData[];\n  };\n}\n\nexport function createSpriteManager(): SpriteManager {\n  return new SpriteManager();\n}\n\nlet spriteId = 0;\n\nexport class SpriteManager {\n  private sprites: SafeMap<string, Sprite> = new SafeMap();\n\n  constructor() {}\n\n  public get(key: string): Sprite {\n    return this.sprites.get(key);\n  }\n\n  public getByPrefix(prefix: string): Sprite[] {\n    const sprites: Sprite[] = [];\n    for (const [key, sprite] of this.sprites.entries()) {\n      if (key.startsWith(prefix)) {\n        sprites.push(sprite);\n      }\n    }\n    return sprites;\n  }\n\n  public async loadSheet(\n    prefix: string,\n    sheetPath: string,\n    sheetData: SheetData\n  ): Promise<void> {\n    await this.sliceSheet(prefix, sheetPath, sheetData);\n  }\n\n  public getSprites(): Sprite[] {\n    return [...this.sprites.values()];\n  }\n\n  private applyScale(frame: SpriteFrameData): SpriteFrameData {\n    return {\n      x: frame.x * SPRITE_SCALE,\n      y: frame.y * SPRITE_SCALE,\n      w: frame.w * SPRITE_SCALE,\n      h: frame.h * SPRITE_SCALE,\n      ox: frame.ox,\n      oy: frame.oy,\n    };\n  }\n\n  private async sliceSheet(\n    prefix: string,\n    sheetPath: string,\n    sheetData: SheetData\n  ): Promise<void> {\n    const sheet = await this.loadAsset(\"sheet\", sheetPath);\n\n    for (const key in sheetData) {\n      const sprite = new Sprite(key);\n      for (let i = 0; i < sheetData[key].frames.length; i++) {\n        const frame = this.applyScale(sheetData[key].frames[i]);\n        this.sliceSprite(sprite, sheet, frame, key, i);\n        this.sprites.set(sprite.getName(), sprite);\n      }\n    }\n  }\n\n  public addSprite(sprite: Sprite): void {\n    this.sprites.set(sprite.getName(), sprite);\n  }\n\n  private sliceSprite(\n    sprite: Sprite,\n    sheet: CanvasRenderingContext2D,\n    frame: SpriteFrameData,\n    prefix: string,\n    suffix = spriteId++\n  ) {\n    const name = `${prefix}_${suffix}`;\n    const sRect = rect(frame.x, frame.y, frame.w, frame.h);\n    const cvs = createCanvas(sRect.w, sRect.h, { willReadFrequently: true });\n    const data = sheet.getImageData(sRect.x, sRect.y, sRect.w, sRect.h);\n    cvs.ctx.putImageData(data, 0, 0);\n\n    if (DEBUG_RESOURCES) {\n      this.debugSprite(name, cvs);\n    }\n\n    sprite.addFrame({\n      img: cvs.ctx.canvas,\n      offset: vec(frame.ox, frame.oy),\n      width: frame.w,\n      height: frame.h,\n    });\n  }\n\n  private debugSprite(name: string, cvs: Canvas): void {\n    const dcvs = cvs.el.cloneNode() as HTMLCanvasElement;\n    const dctx = dcvs.getContext(\"2d\")!; // TODO: (types) don't be lazy\n    const data = cvs.ctx.getImageData(0, 0, cvs.el.width, cvs.el.height);\n    const catalogue = document.getElementById(\"resource-catalogue\")!; // TODO: (types) don't be lazy\n    catalogue.appendChild(dcvs);\n    dctx.putImageData(data, 0, 0);\n    dctx.fillStyle = Color.red().toString();\n    dctx.strokeStyle = Color.red().toString();\n    dctx.fillText(name, 8, 16);\n    dctx.strokeRect(0, 0, cvs.el.width, cvs.el.height);\n  }\n\n  private loadAsset(key: string, path: string): Promise<CTX> {\n    const img = document.createElement(\"img\");\n\n    return new Promise((res, rej) => {\n      img.onerror = rej;\n      img.onload = () => {\n        const sw = img.width * SPRITE_SCALE;\n        const sh = img.height * SPRITE_SCALE;\n        const cvs = createCanvas(sw, sh);\n        cvs.ctx.drawImage(img, 0, 0, sw, sh);\n        cvs.el.setAttribute(\"style\", \"border: 1px solid red\");\n\n        res(cvs.ctx);\n      };\n      img.src = path;\n    });\n  }\n}\n","// TODO: this isn't engine code\n// import { Events } from \"../../town-builder/events/events\";\n\nexport function createEventManager(): EventManager {\n  return new EventManager();\n}\n\nexport type Handler = (payload: any) => void;\n\ninterface FiredEvent {\n  name: string;\n  fired: number;\n}\n\nclass EventManager {\n  private listeners: Map<string, Handler[]> = new Map();\n  private eventsFired: FiredEvent[] = [];\n\n  public listen(event: string, handler: Handler): void {\n    const handlers = this.listeners.get(event);\n    const newHandlers = handlers ? [...handlers, handler] : [handler];\n    this.listeners.set(event, newHandlers);\n  }\n\n  public remove(event: string, handler: Handler): void {\n    const handlers = this.listeners.get(event);\n    if (!handlers) {\n      // TODO: (refactor) move to centralised logger\n      console.warn(\n        \"Attempted to remove handler that was not attached\",\n        event,\n        handler\n      );\n      return;\n    }\n\n    for (const h of handlers) {\n      if (h === handler) {\n        this.listeners.set(\n          event,\n          handlers.filter((hf) => hf !== h)\n        );\n        return;\n      }\n    }\n\n    console.warn(\n      \"Attempted to remove handler that was not attached\",\n      event,\n      handler\n    );\n  }\n\n  // TODO: can we improve the event string & payload type here?\n  public trigger<T>(event: string, payload: T): void {\n    const listener = this.listeners.get(event);\n    if (!listener || !listener.length) {\n      return;\n    }\n\n    this.eventsFired.push({ name: event, fired: Date.now() });\n\n    for (const l of listener) {\n      l(payload as T);\n    }\n  }\n\n  // public debug(filter: Events[]): void {\n  //   let y = 0;\n  //   for (const e of this.eventsFired) {\n  //     if (filter.includes(e.name)) {\n  //       continue;\n  //     }\n  //\n  //     renderer.fillText(`${e.fired}: ${e.name}`, vec(0, y), Color.white());\n  //     y += 16;\n  //   }\n  // }\n}\n","import { Panel, Position, Size } from \"./panel\";\nimport { UI_ENABLED } from \"../settings\";\n\nexport function createUIManager(): UI {\n  return new UI();\n}\n\nexport class UI {\n  private panels: Set<Panel> = new Set();\n\n  public addPanel(panel: Panel): void {\n    this.panels.add(panel);\n  }\n\n  public drawPanel(panel: Panel): void {\n    this.panels.add(panel);\n  }\n\n  public removePanel(pos: Position, size: Size): void {\n    for (const p of this.panels) {\n      if (p.pos === pos && p.size === size) {\n        this.panels.delete(p);\n      }\n    }\n  }\n\n  public update(delta: number): void {}\n\n  public draw(): void {\n    if (!UI_ENABLED) {\n      return;\n    }\n\n    for (const p of this.panels) {\n      p.draw();\n    }\n  }\n}\n","import { ui } from \"../global\";\nimport { createPanel, Panel, Position } from \"../ui/panel\";\nimport { clamp } from \"../maths\";\n\nexport function createNotifications(): Notifications {\n  return new Notifications();\n}\n\nexport interface NotificationTransport {\n  log: (msg: string) => void;\n}\n\ninterface Notification {\n  content: string;\n}\n\nconst NOTIFICATION_DURATION = 10_000;\nconst MAX_VISIBLE_NOTIFICATIONS = 7;\n\nclass Notifications {\n  private notifications: Set<Notification & { created: number }> = new Set();\n  private panel: Panel;\n\n  constructor(private transport: NotificationTransport = console) {\n    this.panel = createPanel(\"\", Position.BottomRight);\n    ui.addPanel(this.panel);\n  }\n\n  public createNotification(notification: Notification): void {\n    this.notifications.add({ ...notification, created: Date.now() });\n    this.transport.log(notification.content);\n  }\n\n  public update(): void {\n    // // TODO (refactor): use the engine delta instead of Date here?\n    // const now = Date.now();\n    // for (const notification of this.notifications) {\n    //   if (now - notification.created >= NOTIFICATION_DURATION) {\n    //     this.notifications.delete(notification);\n    //   }\n    // }\n  }\n\n  public draw(): void {\n    const notifications = [...this.notifications]\n      .sort((a, b) => a.created - b.created)\n      .slice(\n        clamp(\n          this.notifications.size - MAX_VISIBLE_NOTIFICATIONS,\n          0,\n          this.notifications.size\n        )\n      )\n      .map((n) => n.content)\n      .join(\"\\n\");\n\n    this.panel.setContent(notifications);\n  }\n}\n","import { Scene } from \"./scene\";\n\nexport function createSceneManager(): SceneManger {\n  return new SceneManger();\n}\n\nclass SceneManger {\n  private scenes: Scene[] = [];\n  private activeScene: Scene | null = null;\n\n  public start(): Scene {\n    if (!this.scenes.length) {\n      throw new Error(\"no scenes available\");\n    }\n    this.activeScene = this.scenes[0];\n\n    return this.activeScene;\n  }\n\n  public getActiveScene(): Scene {\n    if (this.activeScene === null) {\n      throw new Error(\"no active scene\");\n    }\n    return this.activeScene;\n  }\n\n  public addScene(scene: Scene): void {\n    if (this.scenes.indexOf(scene) !== -1) {\n      return;\n    }\n\n    this.scenes.push(scene);\n  }\n}\n","import { createInputManager } from \"./input/input\";\nimport { createLogger } from \"./logger\";\nimport { createRenderer } from \"./renderer/renderer\";\nimport { createDebugger } from \"./debugger\";\nimport { createCollisionManager } from \"./collision\";\nimport { createCamera } from \"./camera/camera\";\nimport { createSpriteManager } from \"./sprites/sprites\";\nimport { createEventManager } from \"./events/EventManager\";\nimport { createUIManager } from \"./ui/ui\";\nimport { createNotifications } from \"./notifications/notifications\";\nimport { createSceneManager } from \"./scenes/sceneManager\";\nimport { SafeMap } from \"./units/primitives\";\n\nexport const renderer = createRenderer(\n  new SafeMap<string, number>([\n    [\"board\", 200],\n    [\"shadows\", 299],\n    [\"pieces\", 300],\n    [\"cursor_shadows\", 399],\n    [\"cursor_pieces\", 400],\n  ])\n);\nexport const camera = createCamera(renderer);\nexport const debug = createDebugger(renderer.ctx);\nexport const collision = createCollisionManager();\nexport const input = createInputManager(renderer.canvas, camera);\nexport const logger = createLogger();\nexport const sprites = createSpriteManager();\nexport const events = createEventManager();\nexport const ui = createUIManager();\nexport const notifications = createNotifications();\nexport const scenes = createSceneManager();\n","import { Collider } from \"../collider\";\nimport { vec, Vec } from \"../units/vec\";\nimport { StateMachine } from \"../stateMachine\";\nimport { DEBUG_COLLIDERS, DEBUG_STATE } from \"../settings\";\nimport { Grid } from \"../grid\";\n\nexport interface Parent {\n  getWorldPos(): Vec;\n  remove(obj: GameObject): void;\n}\n\nexport type Handler = (obj: GameObject) => void;\n\nexport abstract class GameObject {\n  public offset = vec();\n  public parent: GameObject | null = null;\n  public children: Set<GameObject> = new Set();\n  public collider: Collider | null = null;\n  public enabled = true;\n\n  private handlers = new Map<string, Handler[]>([[\"onPointerDown\", []]]);\n\n  constructor(\n    public id: number,\n    public pos: Vec,\n    public stateMachine: StateMachine | null = null\n  ) {}\n\n  public abstract getName(): string;\n\n  public isEnabled(): boolean {\n    return this.enabled;\n  }\n\n  public getState(): string {\n    if (!this.stateMachine) {\n      throw new Error(\n        `Attempted to access state of obj with no state machine ${this.getName()}`\n      );\n    }\n\n    return this.stateMachine.getActiveState().getName();\n  }\n\n  public update(delta: number): void {\n    this.stateMachine?.update(delta);\n    for (const c of this.children.values()) {\n      c.update(delta);\n    }\n  }\n\n  public addCollider(c: Collider) {\n    this.collider = c;\n    this.collider.obj = this;\n    this.collider.enable();\n  }\n\n  public removeCollider() {\n    this.collider?.destroy();\n    this.collider = null;\n  }\n\n  public getWorldPos(): Vec {\n    let p = this.pos;\n\n    if (this.parent) {\n      p = p.addv(this.parent.getWorldPos());\n    }\n\n    return p;\n  }\n\n  public destroy(): void {\n    this.parent?.remove(this);\n    this.collider?.destroy();\n  }\n\n  public debug(): void {\n    if (DEBUG_COLLIDERS) {\n      this.collider?.debug();\n    }\n\n    if (DEBUG_STATE) {\n      this.stateMachine?.debug();\n    }\n  }\n\n  public add(o: GameObject, worldPos?: Vec): void {\n    if (o.parent) {\n      o.parent.remove(o);\n    }\n\n    o.parent = this;\n    if (worldPos) {\n      o.setPos(worldPos);\n    }\n    this.children.add(o);\n  }\n\n  public setPos(worldPos: Vec): void {\n    this.pos = worldPos;\n  }\n\n  public hasChild(o: GameObject): boolean {\n    return this.children.has(o);\n  }\n\n  public setChildren(...children: GameObject[]): void {\n    this.children = new Set();\n    for (const c of children) {\n      this.add(c);\n    }\n  }\n\n  public remove(o: GameObject, parent: GameObject | null = null): void {\n    this.children.delete(o);\n    o.parent = parent;\n  }\n\n  public getChildrenRecursive(): GameObject[] {\n    const children = [...this.children.values()];\n    for (const c of this.children.values()) {\n      children.push(...c.getChildrenRecursive());\n    }\n    return children;\n  }\n\n  public getChildren(): GameObject[] {\n    return [...this.children.values()];\n  }\n\n  public getParentsRecursive(\n    parent: GameObject | null,\n    parents: GameObject[] = []\n  ): GameObject[] {\n    if (!parent) {\n      return parents;\n    }\n\n    return this.getParentsRecursive(parent.parent, [...parents, parent]);\n  }\n\n  public registerHandler(event: string, handler: Handler): void {\n    const e = this.handlers.get(event);\n    if (e === undefined) {\n      throw new Error(`Cannot register handler, unrecognised event \"${event}\"`);\n    }\n    e.push(handler);\n  }\n\n  public removeHandler(event: string, handler: Handler): void {\n    const e = this.handlers.get(event);\n    if (e === undefined) {\n      throw new Error(`Cannot register handler, unrecognised event \"${event}\"`);\n    }\n    this.handlers.set(\n      event,\n      e.filter((h) => h !== handler)\n    );\n  }\n\n  public onPointerDown(): void {\n    // TODO (cleanup): lazy types and implementation\n    for (const h of this.handlers.get(\"onPointerDown\")!) {\n      h(this);\n    }\n  }\n  public onPointerUp(): void {}\n  public onPointerOver(): void {}\n  public onPointerOut(): void {}\n\n  // TODO (optimize): cache the grid\n  public getGrid(): Grid {\n    const parents = this.getParentsRecursive(this.parent);\n    const err = new Error(\n      `Cannot get grid, it was not the direct parent of ${this.getName()}`\n    );\n\n    if (!parents.length) {\n      throw err;\n    }\n\n    for (const p of parents) {\n      if (p instanceof Grid) {\n        return p;\n      }\n    }\n\n    throw err;\n  }\n}\n","import { vec, Vec } from \"./units/vec\";\nimport { DEBUG_GRID, GRID_UNIT } from \"./settings\";\nimport { debug, input, renderer } from \"./global\";\nimport { Color } from \"./color\";\nimport { GameObject } from \"./objects/gameObject\";\n\nexport function createGrid(\n  width: number,\n  height = width,\n  pos: Vec = vec(),\n  size = GRID_UNIT,\n  factory: NodeFactory = (local, world) => ({ local, world })\n): Grid {\n  return new Grid(width, height, pos, size, factory);\n}\n\nexport interface Node {\n  local: Vec;\n  world: Vec;\n}\n\nexport interface GridNode {\n  local: Vec;\n  world: Vec;\n}\n\nexport type NodeFactory = (local: Vec, world: Vec) => GridNode;\n\nlet id = 0;\n\nexport class Grid extends GameObject {\n  private nodes: GridNode[][] = [];\n\n  constructor(\n    public width: number,\n    public height: number,\n    public pos: Vec,\n    public size: number,\n    private factory: NodeFactory\n  ) {\n    super(id++, pos);\n    this.init();\n  }\n\n  protected init() {\n    for (let x = 0; x < this.width; x++) {\n      if (!this.nodes[x]) this.nodes[x] = [];\n      for (let y = 0; y < this.height; y++) {\n        const local = vec(x, y);\n        this.nodes[x][y] = this.factory(local, this.localToWorld(local));\n      }\n    }\n  }\n\n  public getName(): string {\n    return \"GRID\";\n  }\n\n  public localToWorld(p: Vec): Vec {\n    return Grid.cartToIso(p.addv(this.pos)).multiply(this.size);\n  }\n\n  public draw(): void {\n    renderer.path(\n      [\n        this.localToWorld(vec()).sub(0, this.size / 2),\n        this.localToWorld(vec(this.width, 0)).sub(0, this.size / 2),\n        this.localToWorld(vec(this.width, this.height)).sub(0, this.size / 2),\n        this.localToWorld(vec(0, this.height)).sub(0, this.size / 2),\n        this.localToWorld(vec()).sub(0, this.size / 2),\n      ],\n      Color.white(0.25),\n      4,\n      \"default\"\n    );\n  }\n\n  public debug(): void {\n    if (!DEBUG_GRID) {\n      return;\n    }\n\n    const pos = this.worldToLocalSnap(input.pointer.getWorldPos());\n\n    debug.print(\"GRID\", !pos ? \"OOB\" : pos.local.toString());\n\n    this.forEach(({ local, world }) => {\n      renderer.drawISoRect(\n        // world.add(0, this.size / 2),\n        world,\n        this.size,\n        this.size,\n        Color.red(0.25),\n        false,\n        vec(0, -this.size / 2),\n        2,\n        \"debug\"\n      );\n      renderer.fillRect(\n        world,\n        this.size / 4,\n        this.size / 4,\n        Color.green(0.5),\n        vec(),\n        \"debug\"\n      );\n      renderer.fillText(\n        `${local.x},${local.y}`,\n        world,\n        Color.red(),\n        this.size,\n        \"debug\"\n      );\n    });\n\n    const snapped = this.worldToLocalSnap(\n      Vec.from(input.pointer.getWorldPos())\n    );\n\n    if (snapped) {\n      const { world } = snapped;\n      renderer.fillRect(world, 8, 8, Color.white(), vec(), \"debug\");\n    }\n  }\n\n  public worldToLocalUnsafe(worldPos: Vec): Vec {\n    const snap = this.worldToLocalSnap(worldPos, false);\n    return snap!.local;\n  }\n\n  public worldToLocalSnap(v: Vec, safe = true): Node | null {\n    const local = Grid.isoToCart(v).divide(this.size).round();\n\n    if (safe && !this.contains(local)) {\n      return null;\n    }\n\n    return {\n      local: local,\n      world: this.localToWorld(local),\n    };\n  }\n\n  public getCenter(): Vec {\n    return this.pos.sub(0, Math.floor(this.height / 2) * this.size);\n  }\n\n  private contains(p: Vec): boolean {\n    let cx = false,\n      cy = false;\n\n    // TODO: optimise\n    this.forEach(({ local }) => {\n      if (local.x == p.x) cx = true;\n      if (local.y == p.y) cy = true;\n      if (cx && cy) return;\n    });\n\n    return cx && cy;\n  }\n\n  public forEach(cb: (node: GridNode) => void): void {\n    this.nodes.forEach((row) => {\n      row.forEach((node) => {\n        cb(node);\n      });\n    });\n  }\n\n  static cartToIso(c: Vec): Vec {\n    const i = Vec.from(c);\n    i.x = c.x - c.y;\n    i.y = (c.x + c.y) / 2;\n    return i;\n  }\n\n  static isoToCart(i: Vec): Vec {\n    const c = Vec.from(i);\n    c.x = (2 * i.y + i.x) / 2;\n    c.y = (2 * i.y - i.x) / 2;\n    return c;\n  }\n\n  public add(o: GameObject, localPos = vec()) {\n    super.add(o, this.localToWorld(localPos));\n  }\n}\n","export type Matrix<T> = T[][];\n\nexport function transpose<T>(matrix: Matrix<T>): Matrix<T> {\n  const rows = matrix.length;\n  const cols = matrix[0].length;\n  const result = [];\n\n  for (let j = 0; j < cols; j++) {\n    const newRow = [];\n    for (let i = 0; i < rows; i++) {\n      newRow.push(matrix[i][j]);\n    }\n    result.push(newRow);\n  }\n\n  return result;\n}\n\nexport function flipHorizontally<T>(matrix: Matrix<T>): Matrix<T> {\n  return matrix.map((row) => row.reverse());\n}\n\nexport function flipVertically<T>(matrix: Matrix<T>): Matrix<T> {\n  return matrix.reverse();\n}\n\nexport enum Axis {\n  X,\n  Y,\n}\n\nexport function inverse<T>(matrix: Matrix<T>, axis: Axis): Matrix<T> {\n  switch (axis) {\n    case Axis.X:\n      return matrix.reverse();\n    case Axis.Y:\n      return matrix.map((row) => row.reverse());\n  }\n\n  return matrix;\n}\n","import { vec, Vec } from \"../units/vec\";\nimport { renderer } from \"../global\";\nimport { Color } from \"../color\";\nimport { DEBUG_DISPLAY_OBJS } from \"../settings\";\nimport { GameObject } from \"./gameObject\";\nimport { StateMachine } from \"../stateMachine\";\n\nexport abstract class DisplayObject extends GameObject {\n  constructor(id: number, pos: Vec, stateMachine?: StateMachine) {\n    super(id, pos, stateMachine);\n  }\n\n  public abstract draw(): void;\n\n  public debug(): void {\n    super.debug();\n\n    if (DEBUG_DISPLAY_OBJS) {\n      const p = this.getWorldPos();\n      renderer.fillRect(p, 8, 8, Color.green(), vec(), \"debug\");\n      renderer.fillText(\n        this.getGrid().worldToLocalUnsafe(p).toString() + \"\\n\" + p,\n        p,\n        Color.white(),\n        1000,\n        \"debug\"\n      );\n    }\n  }\n}\n","import { DisplayObject } from \"../../engine/objects/displayObject\";\n\nexport abstract class UIObject extends DisplayObject {\n  public abstract onClick(): void;\n}\n","import { GameObject } from \"./gameObject\";\nimport { DisplayObject } from \"./displayObject\";\nimport { UIObject } from \"../../puzzle-a-day/ui/UIObject\";\n\nexport function filterDisplayObjects(objs: GameObject[]): DisplayObject[] {\n  const t: DisplayObject[] = [];\n  for (const o of objs) {\n    if (o instanceof DisplayObject) {\n      t.push(o);\n    }\n  }\n  return t;\n}\n\nexport function filterUIObjects(objs: GameObject[]): UIObject[] {\n  const t: UIObject[] = [];\n  for (const o of objs) {\n    if (o instanceof UIObject) {\n      t.push(o);\n    }\n  }\n  return t;\n}\n","export function createId(): () => number {\n  let id = 0;\n  return () => {\n    return id++;\n  };\n}\n","import { DisplayObject } from \"./displayObject\";\nimport { vec, Vec } from \"../units/vec\";\nimport { renderer } from \"../global\";\nimport { Color } from \"../color\";\nimport { Sprite } from \"../sprites/sprites\";\n\nexport abstract class SpriteObject extends DisplayObject {\n  constructor(\n    id: number,\n    pos: Vec,\n    public sprite: Sprite,\n    public offset: Vec = vec(),\n    public tint: Color = Color.empty()\n  ) {\n    super(id, pos);\n  }\n\n  public draw(alpha = 1, layer = \"default\", frame = 0): void {\n    const p = this.getWorldPos().addv(this.offset);\n    renderer.renderSprite(\n      this.sprite.getName(),\n      p,\n      this.tint,\n      alpha,\n      layer,\n      frame\n    );\n  }\n}\n","import { DisplayObject } from \"../engine/objects/displayObject\";\nimport { vec } from \"../engine/units/vec\";\nimport { input, renderer } from \"../engine/global\";\nimport { Color } from \"../engine/color\";\nimport { KeyInput, PointerState } from \"../engine/input/input\";\nimport { PieceManager } from \"./global\";\nimport { Piece } from \"./Piece\";\n\nexport function createCursor(): Cursor {\n  return new Cursor(0, vec());\n}\n\nexport class Cursor extends DisplayObject {\n  getName(): string {\n    return \"CURSOR\";\n  }\n\n  private getPiece(): Piece | null {\n    // assume cursor only ever has 1 child\n    // TODO: does this need more enforcement?\n    const child = [...this.children.values()][0];\n    if (child instanceof Piece) {\n      return child;\n    }\n    return null;\n  }\n\n  public add(piece: Piece): void {\n    const grid = PieceManager.getGrid();\n    const cursorLocalPos = grid.worldToLocalUnsafe(this.pos);\n    const pieceLocalPos = grid.worldToLocalUnsafe(piece.pos);\n\n    piece.setAnchor(cursorLocalPos.subv(pieceLocalPos));\n    piece.setPos(piece.pos.subv(this.pos));\n    super.add(piece);\n  }\n\n  public update(delta: number): void {\n    super.update(delta);\n\n    this.pos = input.pointer.getWorldPos();\n    const piece = this.getPiece();\n    const cursorPos = PieceManager.getGrid().worldToLocalSnap(this.pos);\n\n    PieceManager.resetHoverState();\n\n    if (!cursorPos) {\n      return;\n    }\n\n    if (piece) {\n      piece.hovered = true;\n\n      switch (input.getKeyDownThisFrame()) {\n        case KeyInput.Rotate:\n          piece.rotate();\n          break;\n        case KeyInput.Flip:\n          piece.flip();\n          break;\n      }\n\n      PieceManager.updateTempPlacement(piece, cursorPos.local);\n    }\n\n    if (\n      input.isPointerDownThisFrame() &&\n      input.pointer.state === PointerState.Primary\n    ) {\n      if (piece) {\n        piece.hovered = true;\n\n        if (!PieceManager.canPlace(piece, cursorPos.local)) {\n          console.log(\"cannot place at: \", cursorPos.local);\n          return;\n        }\n\n        this.remove(piece);\n        PieceManager.addPieceToGrid(piece, cursorPos.local);\n        piece.animationOffset = vec();\n\n        if (PieceManager.isPuzzleComplete()) {\n          alert(\"WELL DONE\");\n        }\n      } else {\n        const pieceOnGrid = PieceManager.getPieceAt(this.pos);\n        if (pieceOnGrid) {\n          PieceManager.removePieceFromGrid(pieceOnGrid);\n          this.add(pieceOnGrid);\n          pieceOnGrid.animationOffset = pieceOnGrid.animationOffset.add(\n            0,\n            -this.getGrid().size / 2\n          );\n        }\n      }\n    } else {\n      const pieceOnGrid = PieceManager.getPieceAt(this.pos);\n      if (pieceOnGrid) {\n        pieceOnGrid.hovered = true;\n      }\n    }\n  }\n\n  public debug(): void {\n    super.debug();\n    const piece = this.getPiece();\n    if (piece) {\n      piece.debug();\n    }\n  }\n\n  public draw(): void {\n    renderer.fillRect(this.pos, 10, 10, Color.black(), vec(), \"cursor\");\n    renderer.fillRect(this.pos.add(2, 2), 6, 6, Color.white(), vec(), \"cursor\");\n  }\n}\n","import { createId } from \"../engine/id/id\";\nimport { vec, Vec } from \"../engine/units/vec\";\nimport { Color, SerialisedColor } from \"../engine/color\";\nimport { renderer } from \"../engine/global\";\nimport { DEBUG_PIECES, DRAW_PIECES } from \"../engine/settings\";\nimport { PieceManager } from \"./global\";\nimport * as matrix from \"../engine/units/matrix\";\nimport { Axis } from \"../engine/units/matrix\";\nimport { SpriteObject } from \"../engine/objects/spriteObject\";\nimport { wrap } from \"../engine/maths\";\nimport { Sprite } from \"../engine/sprites/sprites\";\nimport { Cursor } from \"./Cursor\";\n\nconst id = createId();\n\ninterface PieceNode {\n  local: Vec;\n  occupied: boolean;\n}\n\n// TODO: move this out of this file, it doesn't belong here\nfunction parse(piece: string): PieceNode[][] {\n  const pGrid: PieceNode[][] = [];\n  const rows = piece.split(\"\\n\").filter((r) => r.length !== 0);\n  for (let y = 0; y < rows.length; y++) {\n    const nodes = rows[y].split(\",\").filter((n) => n !== \"\");\n    for (let x = 0; x < nodes.length; x++) {\n      if (pGrid[x] === undefined) {\n        pGrid[x] = [];\n      }\n\n      switch (nodes[x]) {\n        case \"x\":\n          pGrid[x][y] = {\n            local: vec(x, y),\n            occupied: true,\n          };\n          break;\n        case \"o\":\n          pGrid[x][y] = {\n            local: vec(x, y),\n            occupied: false,\n          };\n          break;\n      }\n    }\n  }\n  return pGrid;\n}\n\nexport function createPiece(\n  name: string,\n  grid: string,\n  anchor: Vec,\n  color: Color,\n  sprite: Sprite,\n  offset = vec(),\n  rotation = 0,\n  pos = vec()\n): Piece {\n  return new Piece(\n    name,\n    pos,\n    parse(grid),\n    color,\n    rotation,\n    anchor,\n    sprite,\n    offset\n  );\n}\n\nexport interface SerialisedPiece {\n  localPos: Vec;\n  shape: PieceNode[][];\n  rotation: number;\n  color: SerialisedColor;\n  anchor: Vec;\n  name: string;\n}\n\nexport class Piece extends SpriteObject {\n  public animationOffset = vec();\n  private anchor = vec();\n  private needsUpdate = false;\n  public hovered: boolean = false;\n\n  constructor(\n    private name: string,\n    pos: Vec,\n    public shape: PieceNode[][],\n    private color: Color,\n    private rotation = 0,\n    anchor = vec(0, 0),\n    sprite: Sprite,\n    offset: Vec\n  ) {\n    super(id(), pos, sprite, vec());\n    this.setAnchor(anchor);\n\n    for (let i = 0; i < this.rotation; i++) {\n      this.rotateNodes();\n    }\n  }\n\n  public getName(): string {\n    return `${this.id}_PIECE`;\n  }\n\n  public setPos(worldPos: Vec): void {\n    if (worldPos.equalsv(this.pos)) {\n      console.warn(\"skipping piece pos update\");\n      return;\n    }\n\n    super.setPos(worldPos);\n\n    if (this.needsUpdate) {\n      PieceManager.updatePiece(this);\n      this.needsUpdate = false;\n    }\n  }\n\n  private rotateNodes(): void {\n    const transposed = matrix.transpose(this.shape);\n    this.shape = matrix.flipVertically(transposed);\n  }\n\n  public rotate(): void {\n    this.needsUpdate = true;\n    this.rotateNodes();\n    this.rotation = wrap(this.rotation + 1, 0, this.sprite.getFrameLen() - 1);\n  }\n\n  public flip(): void {\n    this.needsUpdate = true;\n    switch (this.rotation) {\n      case 0:\n      case 2:\n        this.shape = matrix.inverse(this.shape, Axis.X);\n        return;\n      case 1:\n      case 3:\n        this.shape = matrix.inverse(this.shape, Axis.Y);\n        return;\n    }\n  }\n\n  public getLocalPos(): Vec {\n    const grid = this.getGrid();\n    const pos = grid.worldToLocalSnap(this.pos);\n    if (!pos) {\n      throw new Error(\"Piece not on grid!\");\n    }\n    return pos.local.addv(this.anchor);\n  }\n\n  public getNodes(): Vec[] {\n    const nodes: Vec[] = [];\n    this.forEach((pos, occupied) => {\n      if (!occupied) {\n        return;\n      }\n      nodes.push(pos);\n    });\n    return nodes;\n  }\n\n  public forEach(cb: (pos: Vec, occupied: boolean) => void): void {\n    for (let x = 0; x < this.shape.length; x++) {\n      for (let y = 0; y < this.shape[x].length; y++) {\n        cb(vec(x, y), this.shape[x][y].occupied);\n      }\n    }\n  }\n\n  public draw() {\n    if (!DRAW_PIECES) {\n      return;\n    }\n\n    const pos = this.getWorldPos().addv(this.offset);\n    const isWithCursor = this.parent instanceof Cursor;\n    const name = this.sprite.getName();\n    renderer.renderSprite(\n      name + \"_shadow\",\n      pos,\n      this.tint,\n      1,\n      isWithCursor ? \"cursor_shadows\" : \"shadows\",\n      this.rotation\n    );\n\n    renderer.renderSprite(\n      this.hovered ? name + \"_highlight\" : name,\n      pos.addv(this.animationOffset),\n      this.tint,\n      1,\n      isWithCursor ? \"cursor_pieces\" : \"pieces\",\n      this.rotation\n    );\n  }\n\n  public setAnchor(pos: Vec): void {\n    this.anchor = pos;\n  }\n\n  public getAnchor(): Vec {\n    return this.anchor;\n  }\n\n  public debug(): void {\n    if (!DEBUG_PIECES) {\n      return;\n    }\n\n    super.debug();\n\n    const grid = this.getGrid();\n    const size = grid.size;\n    const wp = this.getWorldPos();\n    const anchor = grid.localToWorld(this.anchor).addv(wp);\n\n    renderer.drawISoRect(\n      anchor,\n      size / 3,\n      size / 3,\n      Color.white(),\n      false,\n      vec(),\n      2,\n      \"debug\"\n    );\n\n    this.forEach((p, occupied) => {\n      const pos = grid.localToWorld(p).addv(wp);\n      renderer.drawISoRect(\n        pos,\n        size,\n        size,\n        this.color,\n        occupied,\n        vec(0, -size / 2),\n        4,\n        \"debug\"\n      );\n    });\n  }\n\n  private serialiseShape(): PieceNode[][] {\n    const grid: PieceNode[][] = [];\n    for (let x = 0; x < this.shape.length; x++) {\n      if (!grid[x]) grid[x] = [];\n      for (let y = 0; y < this.shape[x].length; y++) {\n        grid[x][y] = {\n          local: this.shape[x][y].local,\n          occupied: this.shape[x][y].occupied,\n        };\n      }\n    }\n    return grid;\n  }\n\n  public serialise(): SerialisedPiece {\n    return {\n      // TODO: would be nicer if we didn't have to explicitly add the anchor here,\n      //  can we make the relationship between the pos and anchor implicit? Perhaps\n      //  behind a getLocalPos() interface?\n      localPos: this.getLocalPos(),\n      shape: this.serialiseShape(),\n      rotation: this.rotation,\n      color: this.color.serialise(),\n      anchor: this.anchor,\n      name: this.name,\n    };\n  }\n}\n","import { Piece } from \"./Piece\";\nimport { Grid } from \"../engine/grid\";\nimport { vec, Vec } from \"../engine/units/vec\";\nimport { renderer } from \"../engine/global\";\nimport { Color } from \"../engine/color\";\nimport { DEBUG_PIECE_MANAGER } from \"../engine/settings\";\nimport { Board } from \"./board/Board\";\n\nexport function createPieceManager(): PieceManager {\n  return new PieceManager();\n}\n\nexport class PieceManager {\n  private pieceMatrix: (Piece | null)[][] = [];\n  private pieces: Set<Piece> = new Set();\n  private grid: Grid | null = null;\n  private board: Board | null = null;\n\n  private debugTempPlacement: Vec[] = [];\n\n  public reset(): void {\n    this.pieces.clear();\n\n    for (let x = 0; x < this.pieceMatrix.length; x++) {\n      for (let y = 0; y < this.pieceMatrix[x].length; y++) {\n        this.pieceMatrix[x][y] = null;\n      }\n    }\n  }\n\n  public resetHoverState(): void {\n    for (const p of this.pieces) {\n      p.hovered = false;\n    }\n  }\n\n  public start(grid: Grid) {\n    this.grid = grid;\n    this.grid.forEach((node) => {\n      if (this.pieceMatrix[node.local.x] === undefined) {\n        this.pieceMatrix[node.local.x] = [];\n      }\n      this.pieceMatrix[node.local.x][node.local.y] = null;\n    });\n  }\n\n  public getPieces(): Set<Piece> {\n    return this.pieces;\n  }\n\n  public getGrid(): Grid {\n    if (this.grid === null) {\n      throw new Error(\"Attempted to access grid before it was initialised\");\n    }\n    return this.grid;\n  }\n\n  public getBoard(): Board {\n    if (this.board === null) {\n      throw new Error(\"No board in piece manager\");\n    }\n    return this.board;\n  }\n\n  public getPieceAt(worldPos: Vec): Piece | null {\n    const pos = this.getGrid().worldToLocalSnap(worldPos);\n    if (!pos) {\n      return null;\n    }\n\n    return this.pieceMatrix[pos.local.x][pos.local.y];\n  }\n\n  public removePieceFromGrid(piece: Piece): void {\n    this.getGrid().forEach((node) => {\n      const p = this.pieceMatrix[node.local.x][node.local.y];\n      if (p === piece) {\n        this.pieceMatrix[node.local.x][node.local.y] = null;\n      }\n    });\n    this.pieces.delete(piece);\n  }\n\n  public addBoardToGrid(board: Board, localPos: Vec): void {\n    this.board = board;\n    this.board.updateLocalRect(localPos);\n    this.getGrid().add(board, localPos);\n  }\n\n  public addPieceToGrid(piece: Piece, localPos: Vec) {\n    if (this.pieces.has(piece)) {\n      this.removePieceFromGrid(piece);\n    }\n\n    this.getGrid().add(piece, localPos.subv(piece.getAnchor()));\n    const localPiecePos = this.getGrid().worldToLocalUnsafe(piece.pos);\n\n    const nodes = this.getPieceLocalNodesAtLocalPos(piece, localPiecePos);\n    for (const node of nodes) {\n      this.pieceMatrix[node.x][node.y] = piece;\n    }\n\n    this.pieces.add(piece);\n  }\n\n  public isPuzzleComplete(): boolean {\n    // TODO: handles no board in sandbox mode\n    if (!this.board) {\n      return false;\n    }\n\n    const board = this.getBoard();\n    const solution = board.getSolutionNodes();\n    const freeNodes: Vec[] = [];\n    for (const node of board.getNodes()) {\n      if (this.pieceMatrix[node.x][node.y] === null) {\n        freeNodes.push(Vec.from(node));\n      }\n    }\n\n    return Vec.isMatchingList(solution, freeNodes);\n  }\n\n  public updatePiece(piece: Piece): void {\n    if (!this.pieces.has(piece)) {\n      console.warn(\n        `Cannot update piece ${piece.getName()}, it was not registered`\n      );\n      return;\n    }\n\n    const pos = this.getGrid().worldToLocalSnap(piece.pos);\n\n    if (pos === null) {\n      console.warn(\"Cannot update piece as it is OOB\", piece);\n      return;\n    }\n\n    // TODO: these loops can be consolidated\n    this.removePieceFromGrid(piece);\n    this.addPieceToGrid(piece, pos.local);\n  }\n\n  public updateTempPlacement(piece: Piece, localPos: Vec): void {\n    const localPosWithAnchor = localPos.subv(piece.getAnchor());\n    const nodes = this.getPieceLocalNodesAtLocalPos(piece, localPosWithAnchor);\n    this.debugTempPlacement = nodes.map((p) =>\n      this.getGrid()\n        .localToWorld(p)\n        .sub(0, this.getGrid().size / 2)\n    );\n  }\n\n  public getPieceLocalNodesAtLocalPos(piece: Piece, localPos: Vec): Vec[] {\n    return piece.getNodes().map((p) => p.addv(localPos));\n  }\n\n  public canPlace(piece: Piece, localPos: Vec): boolean {\n    const localPosWithAnchor = localPos.subv(piece.getAnchor());\n    const pieceNodes = this.getPieceLocalNodesAtLocalPos(\n      piece,\n      localPosWithAnchor\n    );\n    for (const node of pieceNodes) {\n      if (this.pieceMatrix[node.x][node.y] !== null) {\n        return false;\n      }\n    }\n\n    // TODO: handles no board in sandbox mode\n    if (!this.board) {\n      return true;\n    }\n\n    if (!this.getBoard().isValidPlacement(pieceNodes)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public debug(): void {\n    if (!DEBUG_PIECE_MANAGER) {\n      return;\n    }\n\n    const size = this.getGrid().size;\n    this.getGrid().forEach((node) => {\n      if (this.pieceMatrix[node.local.x][node.local.y] instanceof Piece) {\n        renderer.fillRect(\n          node.world,\n          size / 4,\n          size / 4,\n          Color.white(),\n          vec(),\n          \"debug\"\n        );\n      }\n    });\n\n    for (const pos of this.debugTempPlacement) {\n      renderer.drawISoRect(\n        pos,\n        this.getGrid().size,\n        this.getGrid().size,\n        Color.green(0.75),\n        true,\n        vec(),\n        4,\n        \"debug\"\n      );\n    }\n  }\n}\n","import { createPiece, Piece } from \"../Piece\";\nimport { Direction, vec, Vec } from \"../../engine/units/vec\";\nimport { SafeMap } from \"../../engine/units/primitives\";\nimport { Color } from \"../../engine/color\";\nimport { sprites } from \"../../engine/global\";\n\ntype PieceFactory = (pos?: Vec, rotation?: number, anchor?: Vec) => Piece;\n\nexport const pieceFactory = new SafeMap<string, PieceFactory>();\n\n// TODO: sprite offset with rotation is hard...\n//  thinking about having this be part of sprites.json so its coupled with the resources\n//  need to adjust the sprite loader to update the sprite object with \"frames\" (which will include the offset)\n//  might need to rethink how sprites are named and set/get\n\nfunction registerPiece(\n  name: string,\n  shape: string,\n  anchor: Vec,\n  color: Color\n): void {\n  pieceFactory.set(name, (pos = vec(), rotation = 0) => {\n    return createPiece(\n      name,\n      shape,\n      anchor,\n      color,\n      sprites.get(name),\n      vec(),\n      rotation,\n      pos\n    );\n  });\n}\n\nregisterPiece(\n  \"piece_0\",\n  `\nx,o,o,\nx,o,o,\nx,o,o,\nx,x,o,\n  `,\n  vec(0, 0),\n  Color.green()\n);\n\nregisterPiece(\n  \"piece_1\",\n  `\nx,o,o,\nx,x,o,\no,x,o,\no,x,o,\n  `,\n  vec(0, 0),\n  Color.green()\n);\n\nregisterPiece(\n  \"piece_2\",\n  `\nx,x,o,\nx,o,o\nx,x,o\n  `,\n  vec(0, 0),\n  Color.green()\n);\n\nregisterPiece(\n  \"piece_3\",\n  `\nx,o,o\nx,x,o\nx,x,o\n  `,\n  vec(0, 0),\n  Color.green()\n);\n\nregisterPiece(\n  \"piece_4\",\n  `\nx,o,o\nx,o,o\nx,x,x\n  `,\n  vec(0, 0),\n  Color.green()\n);\n\nregisterPiece(\n  \"piece_5\",\n  `\nx,o,o\nx,x,o\nx,o,o\nx,o,o\n  `,\n  vec(0, 0),\n  Color.green()\n);\n\nregisterPiece(\n  \"piece_6\",\n  `\nx,x,o\nx,x,o\nx,x,o\n  `,\n  vec(0, 0),\n  Color.green()\n);\n\nregisterPiece(\n  \"piece_7\",\n  `\no,x,x\no,x,o\nx,x,o\n  `,\n  vec(1, 0),\n  Color.green()\n);\n","import { SerialisedPiece } from \"../Piece\";\nimport { PieceManager } from \"../global\";\nimport { input, scenes } from \"../../engine/global\";\nimport { KeyInput } from \"../../engine/input/input\";\nimport { Vec, vec } from \"../../engine/units/vec\";\nimport { pieceFactory } from \"../pieces/piece-factory\";\n\nexport function createGameState(): GameState {\n  return new GameState();\n}\n\nexport interface SerialisedGameState {\n  pieces: SerialisedPiece[];\n}\n\nclass GameState {\n  private savedState: SerialisedGameState | null = null;\n\n  public update(): void {\n    if (input.getKeyDownThisFrame() === KeyInput.Save) {\n      this.saveState();\n      return;\n    }\n\n    if (input.getKeyDownThisFrame() === KeyInput.Load) {\n      this.loadState();\n      return;\n    }\n  }\n\n  private getSaveStateKey(): string {\n    return \"puzzle-a-day:game-state\";\n  }\n\n  public saveState(): void {\n    const pieces: SerialisedPiece[] = [];\n    for (const piece of PieceManager.getPieces()) {\n      pieces.push(piece.serialise());\n    }\n\n    const state: SerialisedGameState = {\n      pieces,\n    };\n\n    localStorage.setItem(this.getSaveStateKey(), JSON.stringify(state));\n    console.log(\"saved scene!\", state);\n  }\n\n  public loadState(state?: SerialisedGameState): void {\n    const scene = scenes.getActiveScene();\n    scene.reset();\n\n    if (!state) {\n      const savedState = localStorage.getItem(this.getSaveStateKey());\n      if (!savedState) {\n        return;\n      }\n      state = JSON.parse(savedState) as SerialisedGameState;\n    }\n\n    for (const p of state.pieces) {\n      const anchor = Vec.from(p.anchor);\n      const piece = pieceFactory.get(p.name)!(\n        vec(),\n        p.rotation,\n        Vec.from(p.anchor)\n      );\n      PieceManager.addPieceToGrid(piece, Vec.from(p.localPos));\n    }\n\n    console.log(\"loaded scene!\", state);\n  }\n}\n","import { vec } from \"../engine/units/vec\";\nimport { createPieceManager } from \"./PieceManager\";\nimport { createGameState } from \"./game-state/GameState\";\n\nexport const PieceManager = createPieceManager();\nexport const GameState = createGameState();\n","import { collision, debug, input } from \"../global\";\nimport { createGrid, Grid } from \"../grid\";\nimport { DEBUG_SCENE } from \"../settings\";\nimport { GameObject } from \"../objects/gameObject\";\nimport { vec, Vec } from \"../units/vec\";\nimport { filterDisplayObjects, filterUIObjects } from \"../objects/helperts\";\nimport { DisplayObject } from \"../objects/displayObject\";\nimport { PieceManager } from \"../../puzzle-a-day/global\";\nimport { UIObject } from \"../../puzzle-a-day/ui/UIObject\";\n\nexport function createScene(\n  name = \"main\",\n  width: number,\n  height: number\n): Scene {\n  return new Scene(name, createGrid(width, height));\n}\n\ntype ObjFactory = () => GameObject;\n\nexport class Scene {\n  private ui: Set<UIObject> = new Set();\n\n  constructor(public name: string, public grid: Grid) {}\n\n  public reset(): void {\n    for (const child of this.grid.getChildren()) {\n      // TODO: I don't think the cursor should even be here...\n      if (child.getName() === \"CURSOR\") {\n        continue;\n      }\n      this.grid.remove(child);\n    }\n    PieceManager.reset();\n  }\n\n  public addGameObject(obj: GameObject, localPos: Vec = vec()): void {\n    this.grid.add(obj, localPos);\n  }\n\n  public addUIObject(obj: UIObject, screenPos: Vec): void {\n    this.ui.add(obj);\n    obj.pos = screenPos;\n  }\n\n  public fill(factory: ObjFactory): void {\n    this.grid.forEach(({ world, local }) => {\n      this.grid.add(factory(), local);\n    });\n  }\n\n  public update(delta: number): void {\n    for (const obj of this.grid.children) {\n      obj.update(delta);\n    }\n\n    for (const ui of this.ui) {\n      ui.update(delta);\n    }\n  }\n\n  public draw(): void {\n    this.grid.draw();\n    // TODO (optimize): casting children to new array\n    // TODO (refactor): should get children recursive and filter, a GameObject _should_\n    //  be able to have display object children, workaround atm is to make grid children\n    //  display objects arbitrarily\n    // TODO: (optimize): multiple loops to filter & draw display objs\n    for (const child of this.grid.children) {\n      const objs = filterDisplayObjects(child.getChildrenRecursive());\n      if (child instanceof DisplayObject) {\n        child.draw();\n      }\n      for (const dobj of objs) {\n        dobj.draw();\n      }\n    }\n\n    for (const ui of this.ui) {\n      const objs = filterUIObjects(ui.getChildrenRecursive());\n      ui.draw();\n      for (const o of objs) {\n        o.draw();\n      }\n    }\n  }\n\n  public debug(): void {\n    this.grid.debug();\n\n    for (const obj of this.grid.children) {\n      obj.debug();\n    }\n\n    if (DEBUG_SCENE) {\n      const children = this.grid.getChildrenRecursive();\n      const ui: UIObject[] = [];\n      for (const u of this.ui) {\n        const c = filterUIObjects(u.getChildrenRecursive());\n        ui.push(u, ...c);\n      }\n      debug.print(\"scene\", this.name);\n      debug.print(\"objects\", children.length);\n      debug.print(\"ui\", ui.length);\n    }\n  }\n\n  public getAllObjects(): void {\n    const objs = [];\n    for (const c of this.grid.children) {\n      objs.push(...c.getChildrenRecursive());\n    }\n    console.log(objs);\n  }\n}\n","import { DisplayObject } from \"./objects/displayObject\";\nimport { vec, Vec } from \"./units/vec\";\nimport { collision, debug, input } from \"./global\";\nimport { GameObject } from \"./objects/gameObject\";\nimport { DEBUG_COLLISION, GRID_UNIT } from \"./settings\";\nimport { Node } from \"./grid\";\n\nexport function createCursor(pos: Vec): Cursor {\n  return new Cursor(0, pos);\n}\n\nexport interface SnapTo {\n  snapTo(p: Vec): Node | null;\n}\n\nexport class Cursor extends DisplayObject {\n  private obj: GameObject | null = null;\n  private pointerDown = false;\n\n  public offset: Vec = vec(0, GRID_UNIT / 4);\n  public snapParent: SnapTo | null = null;\n\n  public getName(): string {\n    return \"CURSOR\";\n  }\n\n  public update(): void {\n    const sortVecY = (objs: GameObject[]): GameObject[] => {\n      return objs.sort((a, b) => {\n        return a.pos.y - b.pos.y;\n      });\n    };\n\n    /**\n     * Get obj underneath pointer\n     */\n    const hits = sortVecY(collision.getObjAt(input.pointer.getWorldPos()));\n    let hit = hits.pop() ?? null;\n\n    if (hit !== this.obj) {\n      this.obj?.onPointerOut();\n    }\n\n    this.obj = hit;\n    this.obj?.onPointerOver();\n\n    if (DEBUG_COLLISION) {\n      debug.print(\n        \"COLLISION\",\n        this.obj ? `${this.obj?.id}_${this.obj?.getName()}` : \"null\"\n      );\n    }\n\n    if (this.obj === null) {\n      return;\n    }\n\n    // assume the position of the collision obj\n    this.pos = this.obj.getWorldPos().clone();\n\n    if (!this.pointerDown && input.isPointerDown()) {\n      this.pointerDown = true;\n      this.obj.onPointerDown();\n    }\n\n    if (this.pointerDown && !input.isPointerDown()) {\n      this.pointerDown = false;\n    }\n  }\n\n  public draw(): void {}\n\n  public debug(): void {\n    let v = this.pos.toString();\n\n    if (this.obj) {\n      v += ` \"${this.obj.getName()}\" ${this.obj.pos.toString()}`;\n    }\n\n    debug.print(\"cursor\", v);\n  }\n}\n","import {\n  camera,\n  collision,\n  debug,\n  input,\n  notifications,\n  renderer,\n  scenes,\n  ui,\n} from \"./global\";\nimport { DEBUG, FPS, PAUSE } from \"./settings\";\nimport { Scene } from \"./scenes/scene\";\n// TODO (refactor): this is not engine code...\nimport { createCursor } from \"./cursor\";\nimport { vec } from \"./units/vec\";\nimport { PieceManager } from \"../puzzle-a-day/global\";\n\ntype StartFn = (scene: Scene) => void;\ntype UpdateFn = (delta: number) => void;\ntype DrawFn = () => void;\ntype DebugFn = () => void;\n\n// TODO: debug code\nconst cursor = createCursor(vec());\n\nexport function startRuntime(\n  start: StartFn,\n  update: UpdateFn,\n  draw: DrawFn,\n  debug: DebugFn\n): void {\n  const r = new Runtime(start, update, draw, debug);\n  void r.start();\n}\n\nclass Runtime {\n  private frame = 0;\n  private lastFrame = 0;\n\n  constructor(\n    private gameStart: StartFn,\n    private gameUpdate: UpdateFn,\n    private gameDraw: DrawFn,\n    private gameDebug: DebugFn\n  ) {}\n\n  public async start(): Promise<void> {\n    const scene = scenes.start();\n    input.start();\n    (window as any).__scene = scene;\n    (window as any).__pm = PieceManager;\n    try {\n      await this.gameStart(scene);\n    } catch (err) {\n      console.error(\"error starting game\", err);\n    }\n    this.tick();\n  }\n\n  public tick(): void {\n    // TODO: how expensive is this vs caching active scene in the runtime?\n    const scene = scenes.getActiveScene();\n    const start = Date.now();\n    const delta = start - this.lastFrame;\n\n    renderer.clear();\n\n    // Updates\n    input.update();\n    ui.update(delta);\n    scene.update(delta);\n    // TODO: debug code\n    cursor.update();\n    notifications.update();\n    camera.update(delta);\n    this.gameUpdate(delta);\n\n    // Draw\n    scene.draw();\n    notifications.draw();\n    ui.draw();\n    this.gameDraw();\n\n    // Debug\n    scene.debug();\n    input.debug();\n    collision.debug();\n    this.gameDebug();\n\n    // Camera\n    camera.draw();\n    camera.debug();\n\n    const duration = Date.now() - start;\n    const remainingDelta = 1000 / FPS - duration;\n\n    if (DEBUG) {\n      this.debug(delta, remainingDelta);\n      debug.draw();\n    }\n\n    if (!PAUSE) {\n      this.lastFrame = start;\n      setTimeout(this.tick.bind(this), remainingDelta);\n    }\n  }\n\n  public debug(delta: number, remaining: number): void {\n    debug.sample(\"FPS AVG\", delta, FPS, (value) => {\n      return (1000 / value).toFixed(2);\n    });\n    debug.sample(\"FRAME HEADROOM\", remaining, FPS, (value) => {\n      return value.toFixed(2) + \"ms\";\n    });\n    debug.print(\"FRAME\", ++this.frame);\n  }\n}\n","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"1vJCw\")).toString();","{\n  \"piece_0\": {\n    \"frames\": [\n      {\n        \"x\": 0,\n        \"y\": 0,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -128,\n        \"oy\": -48\n      },\n      {\n        \"x\": 96,\n        \"y\": 0,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -64\n      },\n      {\n        \"x\": 192,\n        \"y\": 0,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -32\n      },\n      {\n        \"x\": 288,\n        \"y\": 0,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -32\n      }\n    ]\n  },\n  \"piece_1\": {\n    \"frames\": [\n      {\n        \"x\": 0,\n        \"y\": 128,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -128,\n        \"oy\": -48\n      },\n      {\n        \"x\": 96,\n        \"y\": 128,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -64\n      },\n      {\n        \"x\": 192,\n        \"y\": 128,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -32\n      },\n      {\n        \"x\": 288,\n        \"y\": 128,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -32\n      }\n    ]\n  },\n  \"piece_2\": {\n    \"frames\": [\n      {\n        \"x\": 0,\n        \"y\": 256,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -64\n      },\n      {\n        \"x\": 96,\n        \"y\": 256,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -64\n      },\n      {\n        \"x\": 192,\n        \"y\": 256,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -48\n      },\n      {\n        \"x\": 288,\n        \"y\": 256,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -48\n      }\n    ]\n  },\n  \"piece_3\": {\n    \"frames\": [\n      {\n        \"x\": 0,\n        \"y\": 384,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -64\n      },\n      {\n        \"x\": 96,\n        \"y\": 384,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -80\n      },\n      {\n        \"x\": 192,\n        \"y\": 384,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -32,\n        \"oy\": -48\n      },\n      {\n        \"x\": 288,\n        \"y\": 384,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -48\n      }\n    ]\n  },\n  \"piece_4\": {\n    \"frames\": [\n      {\n        \"x\": 0,\n        \"y\": 512,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -48\n      },\n      {\n        \"x\": 96,\n        \"y\": 512,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -16\n      },\n      {\n        \"x\": 192,\n        \"y\": 512,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -32,\n        \"oy\": -48\n      },\n      {\n        \"x\": 288,\n        \"y\": 512,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -48\n      }\n    ]\n  },\n  \"piece_5\": {\n    \"frames\": [\n      {\n        \"x\": 0,\n        \"y\": 640,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -128,\n        \"oy\": -64\n      },\n      {\n        \"x\": 96,\n        \"y\": 640,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -32,\n        \"oy\": -64\n      },\n      {\n        \"x\": 192,\n        \"y\": 640,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -32\n      },\n      {\n        \"x\": 288,\n        \"y\": 640,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -32\n      }\n    ]\n  },\n  \"piece_6\": {\n    \"frames\": [\n      {\n        \"x\": 0,\n        \"y\": 768,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -64\n      },\n      {\n        \"x\": 96,\n        \"y\": 768,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -64\n      },\n      {\n        \"x\": 0,\n        \"y\": 768,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -48\n      },\n      {\n        \"x\": 96,\n        \"y\": 768,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -48\n      }\n    ]\n  },\n  \"piece_7\": {\n    \"frames\": [\n      {\n        \"x\": 0,\n        \"y\": 896,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -64\n      },\n      {\n        \"x\": 96,\n        \"y\": 896,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -48\n      },\n      {\n        \"x\": 0,\n        \"y\": 896,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -96,\n        \"oy\": -64\n      },\n      {\n        \"x\": 96,\n        \"y\": 896,\n        \"w\": 96,\n        \"h\": 64,\n        \"ox\": -64,\n        \"oy\": -48\n      }\n    ]\n  },\n  \"board\": {\n    \"frames\": [\n      {\n        \"x\": 419,\n        \"y\": 43,\n        \"w\": 208,\n        \"h\": 110,\n        \"ox\": 0,\n        \"oy\": 6\n      }\n    ]\n  }\n}","import { vec, Vec } from \"../../engine/units/vec\";\nimport { SpriteObject } from \"../../engine/objects/spriteObject\";\nimport { events, renderer, sprites } from \"../../engine/global\";\nimport { Color } from \"../../engine/color\";\nimport { DEBUG_BOARD, GRID_UNIT } from \"../../engine/settings\";\nimport { rect, Rect } from \"../../engine/units/rect\";\nimport { SafeMap } from \"../../engine/units/primitives\";\nimport { Sprite } from \"../../engine/sprites/sprites\";\n\nexport function createBoard(\n  localWidth: number,\n  localHeight: number,\n  invalidNodes: Vec[],\n  solution: Vec[]\n): Board {\n  return new Board(\n    0,\n    vec(),\n    sprites.get(\"board\"),\n    localWidth,\n    localHeight,\n    invalidNodes,\n    solution\n  );\n}\n\nconst months = new SafeMap<number, Vec>([\n  [0, vec(0, 1)],\n  [1, vec(0, 2)],\n  [2, vec(0, 3)],\n  [3, vec(0, 4)],\n  [4, vec(0, 5)],\n  [5, vec(0, 6)],\n\n  [6, vec(1, 1)],\n  [7, vec(1, 2)],\n  [8, vec(1, 3)],\n  [9, vec(1, 4)],\n  [10, vec(1, 5)],\n  [11, vec(1, 6)],\n]);\n\nconst days = new SafeMap<number, Vec>([\n  [7, vec(2, 0)],\n  [6, vec(2, 1)],\n  [5, vec(2, 2)],\n  [4, vec(2, 3)],\n  [3, vec(2, 4)],\n  [2, vec(2, 5)],\n  [1, vec(2, 6)],\n\n  [14, vec(3, 0)],\n  [13, vec(3, 1)],\n  [12, vec(3, 2)],\n  [11, vec(3, 3)],\n  [10, vec(3, 4)],\n  [9, vec(3, 5)],\n  [8, vec(3, 6)],\n\n  [21, vec(4, 0)],\n  [20, vec(4, 1)],\n  [19, vec(4, 2)],\n  [18, vec(4, 3)],\n  [17, vec(4, 4)],\n  [16, vec(4, 5)],\n  [15, vec(4, 6)],\n\n  [28, vec(5, 0)],\n  [27, vec(5, 1)],\n  [26, vec(5, 2)],\n  [25, vec(5, 3)],\n  [24, vec(5, 4)],\n  [23, vec(5, 5)],\n  [22, vec(5, 6)],\n\n  [31, vec(6, 4)],\n  [30, vec(6, 5)],\n  [29, vec(6, 6)],\n]);\n\nexport class Board extends SpriteObject {\n  private localRect: Rect;\n  constructor(\n    id: number,\n    pos: Vec,\n    sprite: Sprite,\n    private localWidth: number,\n    private localHeight: number,\n    private invalidNodes: Vec[],\n    private solution: Vec[]\n  ) {\n    super(id, pos, sprite, vec(-GRID_UNIT * 7, -GRID_UNIT / 2));\n    this.localRect = rect(0, 0, this.localWidth, this.localHeight);\n\n    events.listen(\"update_date\", (payload: { date: Date }) => {\n      this.solution[0] = months.get(payload.date.getMonth());\n      this.solution[1] = days.get(payload.date.getDate());\n    });\n  }\n\n  public getName(): string {\n    return \"BOARD\";\n  }\n\n  public getLocalPos(): Vec {\n    return this.getGrid().worldToLocalUnsafe(this.pos);\n  }\n\n  public updateLocalRect(localPos: Vec): void {\n    this.localRect.pos = localPos.clone();\n  }\n\n  public isValidPlacement(nodes: Vec[]): boolean {\n    // TODO (optimize): erm, yeah, a bit loop happy\n\n    // if some nodes are in invalid positions\n    const invalidNodesLocal = this.invalidNodes.map((n) =>\n      n.addv(this.getLocalPos())\n    );\n\n    if (nodes.some((p) => invalidNodesLocal.find((n) => n.equalsv(p)))) {\n      return false;\n    }\n\n    // if every node is in the board\n    if (nodes.every((p) => this.localRect.contains(p))) {\n      return true;\n    }\n\n    // if no nodes are in the board\n    if (nodes.every((p) => !this.localRect.contains(p))) {\n      return true;\n    }\n\n    // some nodes are in the board, but not all\n    return false;\n  }\n\n  public draw() {\n    super.draw(1, \"board\");\n\n    const grid = this.getGrid();\n    for (const p of this.solution) {\n      renderer.drawISoRect(\n        this.getWorldPos().addv(grid.localToWorld(p)),\n        grid.size,\n        grid.size,\n        Color.green(),\n        false,\n        vec(0, -grid.size / 2),\n        4,\n        \"board\"\n      );\n    }\n  }\n\n  public getNodes(): Vec[] {\n    const pos = this.getLocalPos();\n    const nodes: Vec[] = [];\n    for (let x = 0; x < this.localRect.width; x++) {\n      for (let y = 0; y < this.localRect.height; y++) {\n        const node = vec(x, y);\n        if (this.invalidNodes.find((n) => n.equalsv(node))) {\n          continue;\n        }\n        nodes.push(node.addv(pos));\n      }\n    }\n    return nodes;\n  }\n\n  public getSolutionNodes(): Vec[] {\n    return this.solution.map((p) => p.addv(this.getLocalPos()));\n  }\n\n  public debug() {\n    if (!DEBUG_BOARD) {\n      return;\n    }\n    const grid = this.getGrid();\n    renderer.fillText(\n      this.localRect.toString(),\n      this.pos,\n      Color.white(),\n      999,\n      \"debug\"\n    );\n    renderer.drawISoRect(\n      this.pos,\n      this.localRect.width * grid.size,\n      this.localRect.height * grid.size,\n      Color.white(0.5),\n      true,\n      vec(0, -grid.size / 2),\n      4,\n      \"debug\"\n    );\n\n    for (const node of this.solution) {\n      const pos = this.pos.addv(this.getGrid().localToWorld(node));\n      renderer.drawISoRect(\n        pos,\n        GRID_UNIT,\n        GRID_UNIT,\n        Color.green(0.75),\n        true,\n        vec(0, -GRID_UNIT / 2),\n        4,\n        \"debug\"\n      );\n    }\n\n    for (const node of this.invalidNodes) {\n      const pos = this.pos.addv(this.getGrid().localToWorld(node));\n      renderer.drawISoRect(\n        pos,\n        GRID_UNIT,\n        GRID_UNIT,\n        Color.red(0.5),\n        true,\n        vec(0, -GRID_UNIT / 2),\n        4,\n        \"debug\"\n      );\n    }\n  }\n}\n","import { UIObject } from \"../ui/UIObject\";\nimport { Day } from \"./calendar\";\nimport { vec, Vec } from \"../../engine/units/vec\";\nimport { events, renderer } from \"../../engine/global\";\nimport { GRID_UNIT } from \"../../engine/settings\";\nimport { Color } from \"../../engine/color\";\n\nexport function createDate(day: Day, pos: Vec, active: boolean): CalendarDate {\n  return new CalendarDate(day.date.getTime(), pos, day, active);\n}\n\nexport class CalendarDate extends UIObject {\n  public static Width = GRID_UNIT * 2.5;\n  public static Height = GRID_UNIT * 2.5;\n  public static Padding = GRID_UNIT / 2;\n  constructor(id: number, pos: Vec, private day: Day, private active: boolean) {\n    super(id, pos);\n  }\n  public draw(): void {\n    renderer.fillRect(\n      this.getWorldPos(),\n      CalendarDate.Width,\n      CalendarDate.Height,\n      this.active ? Color.white() : Color.red(),\n      vec(),\n      \"ui\"\n    );\n    renderer.fillText(\n      `${this.day.date.getDate()}/${this.day.date.getMonth() + 1}`,\n      this.getWorldPos(),\n      Color.green(),\n      CalendarDate.Width,\n      \"ui\"\n    );\n  }\n\n  public setActive(active: boolean): void {\n    this.active = active;\n  }\n\n  public getDay(): Day {\n    return this.day;\n  }\n\n  public getName(): string {\n    return \"\";\n  }\n\n  public onClick(): void {\n    events.trigger<{ date: Date }>(\"update_date\", { date: this.day.date });\n  }\n}\n","import { createId } from \"../../engine/id/id\";\nimport { UIObject } from \"../ui/UIObject\";\nimport { Vec, vec } from \"../../engine/units/vec\";\nimport { events, renderer } from \"../../engine/global\";\nimport { CalendarDate } from \"./CalendarDate\";\nimport { Color } from \"../../engine/color\";\n\nconst getId = createId();\n\nexport function createCalendarNav(dir: number): CalendarNav {\n  return new CalendarNav(getId(), vec(), dir);\n}\n\nexport class CalendarNav extends UIObject {\n  constructor(id: number, pos: Vec, private dir: number) {\n    super(id, pos);\n  }\n\n  public getDir(): number {\n    return this.dir;\n  }\n\n  public draw(): void {\n    renderer.fillRect(\n      this.getWorldPos(),\n      CalendarDate.Width,\n      CalendarDate.Height,\n      Color.green(),\n      vec(),\n      \"ui\"\n    );\n    renderer.fillText(\n      this.dir.toString(),\n      this.getWorldPos(),\n      Color.white(),\n      CalendarDate.Width,\n      \"ui\"\n    );\n  }\n\n  public getName(): string {\n    return \"UI_NAV_\" + this.id;\n  }\n\n  public onClick() {\n    events.trigger<{ dir: number }>(\"calendar_nav\", { dir: this.dir });\n  }\n}\n","import { SafeMap } from \"../../engine/units/primitives\";\nimport { UIObject } from \"../ui/UIObject\";\nimport { events, input, renderer } from \"../../engine/global\";\nimport { vec, Vec } from \"../../engine/units/vec\";\nimport { Color } from \"../../engine/color\";\nimport { CalendarDate, createDate } from \"./CalendarDate\";\nimport { PointerState } from \"../../engine/input/input\";\nimport { Rect } from \"../../engine/units/rect\";\nimport { CalendarNav, createCalendarNav } from \"./CalendarNavigation\";\n\nexport interface Day {\n  date: Date;\n  complete: boolean;\n}\n\ntype CalendarData = SafeMap<string, Day>;\n\nfunction getDays(): CalendarData {\n  const today = new Date();\n  const year = today.getFullYear();\n  const start = new Date(today.getFullYear(), 0, 1);\n  const days: CalendarData = new SafeMap();\n  let lastDay = start;\n\n  while (lastDay.getFullYear() === year) {\n    days.set(lastDay.toString(), { date: lastDay, complete: false });\n    const d = new Date(lastDay);\n    d.setDate(d.getDate() + 1);\n    lastDay = d;\n  }\n\n  return days;\n}\n\nfunction getDay(days: CalendarData, today: Date): Day {\n  const index = new Date(\n    today.getFullYear(),\n    today.getMonth(),\n    today.getDate()\n  );\n  return days.get(index.toString());\n}\n\nfunction isSameDay(a: Date, b: Date): boolean {\n  return (\n    a.getDate() === b.getDate() &&\n    a.getFullYear() === b.getFullYear() &&\n    a.getMonth() === b.getMonth()\n  );\n}\n\nexport function createCalendar(\n  width: number,\n  height: number,\n  active: Date\n): Calendar {\n  return new Calendar(0, vec(), width, height, Color.black(), active);\n}\n\nclass Calendar extends UIObject {\n  private days = getDays();\n\n  constructor(\n    id: number,\n    pos: Vec,\n    public width: number,\n    public height: number,\n    private color: Color,\n    private activeDate: Date\n  ) {\n    super(id, pos);\n\n    this.updateDays();\n    this.add(createCalendarNav(-1), vec(CalendarDate.Padding, 0));\n    this.add(\n      createCalendarNav(1),\n      vec(renderer.stage.width - (CalendarDate.Padding + CalendarDate.Width), 0)\n    );\n\n    events.listen(\"calendar_nav\", (payload: { dir: number }) => {\n      this.updateDateByDir(payload.dir);\n    });\n  }\n\n  private updateDateByDir(dir: number): void {\n    if (dir === 1) {\n      const d = new Date(this.activeDate);\n      d.setDate(d.getDate() + 1);\n      this.activeDate = d;\n      this.updateDays();\n    }\n\n    if (dir === -1) {\n      const d = new Date(this.activeDate);\n      d.setDate(d.getDate() - 1);\n      this.activeDate = d;\n      this.updateDays();\n    }\n  }\n\n  public getName(): string {\n    return \"UI_CALENDAR\";\n  }\n\n  public update(delta: number): void {\n    if (\n      input.isPointerDownThisFrame() &&\n      input.pointer.state === PointerState.Primary &&\n      this.isInside(input.pointer.getScreenPos())\n    ) {\n      const ui = this.getControlAtPos(input.pointer.getScreenPos());\n      if (ui !== null) {\n        ui.onClick();\n\n        if (ui instanceof CalendarDate) {\n          this.activeDate = ui.getDay().date;\n          console.log(this.activeDate);\n        }\n\n        if (ui instanceof CalendarNav) {\n          events.trigger<{ date: Date }>(\"update_date\", {\n            date: this.activeDate,\n          });\n        }\n\n        this.updateDays();\n      }\n    }\n  }\n\n  private updateDays() {\n    for (const c of this.children) {\n      if (c instanceof CalendarDate) {\n        this.remove(c);\n      }\n    }\n\n    const range = this.getDaysToDraw();\n    const rangeWidth =\n      range.length * (CalendarDate.Width + CalendarDate.Padding) -\n      CalendarDate.Padding;\n    let x = renderer.stage.width / 2 - rangeWidth / 2;\n    for (const d of range) {\n      this.add(createDate(d, vec(x, 0), isSameDay(d.date, this.activeDate)));\n      x += CalendarDate.Width + CalendarDate.Padding;\n    }\n  }\n\n  private getControlAtPos(pos: Vec): UIObject | null {\n    const days = [...this.children] as UIObject[];\n    for (const d of days) {\n      const r = Rect.getRect({\n        pos: d.getWorldPos(),\n        width: CalendarDate.Width,\n        height: CalendarDate.Height,\n      });\n      if (r.contains(pos)) {\n        return d;\n      }\n    }\n    return null;\n  }\n\n  private isInside(pos: Vec): boolean {\n    const rect = Rect.getRect(this);\n    return rect.contains(pos);\n  }\n\n  private getDaysToDraw(): Day[] {\n    const today = getDay(this.days, this.activeDate);\n    const days: Day[] = [today];\n    let lastPositiveDay = today.date;\n    let lastNegativeDay = today.date;\n\n    for (let i = 0; i < this.getDrawableDayLength() - 1; i++) {\n      if (i % 2 !== 0) {\n        const d = new Date(lastPositiveDay);\n        d.setDate(d.getDate() + 1);\n        days.push(getDay(this.days, d));\n        lastPositiveDay = d;\n      } else {\n        const d = new Date(lastNegativeDay);\n        d.setDate(d.getDate() - 1);\n        days.unshift(getDay(this.days, d));\n        lastNegativeDay = d;\n      }\n    }\n\n    return days;\n  }\n\n  private getDrawableDayLength(): number {\n    const days = Math.floor(\n      renderer.stage.width / (CalendarDate.Width + CalendarDate.Padding) - 2\n    );\n    if (days % 2 === 0) {\n      return days - 1;\n    }\n\n    return days;\n  }\n\n  public draw(): void {\n    renderer.fillRect(\n      this.pos,\n      this.width,\n      this.height,\n      this.color,\n      vec(),\n      \"ui\"\n    );\n  }\n\n  onClick(): void {}\n}\n","import { Vec } from \"../units/vec\";\nimport { Color } from \"../color\";\n\nexport type Pixel = [r: number, g: number, b: number, a: number];\n\nexport function pixelsToGrid(\n  pixels: Pixel[],\n  width: number,\n  height: number\n): Pixel[][] {\n  const grid: Pixel[][] = [];\n  let row = 0;\n  let column = 0;\n  for (let i = 0; i < pixels.length; i++) {\n    if (column < width) {\n      if (!grid[column]) grid[column] = [];\n    } else {\n      column = 0;\n      row++;\n    }\n\n    grid[row][column++] = pixels[i];\n  }\n  return grid;\n}\n\nexport function groupByRGB(values: number[]): Pixel[] {\n  const pixels: Pixel[] = [];\n  for (let i = 0; i < values.length; i += 4) {\n    pixels.push([values[i], values[i + 1], values[i + 2], values[i + 3]]);\n  }\n  return pixels;\n}\n\nexport function isTransparent(pixel: Pixel): boolean {\n  return pixel[3] === 0;\n}\n\nexport function isColour(pixel: Pixel, color: Color): boolean {\n  return (\n    pixel[0] === color.r &&\n    pixel[1] === color.g &&\n    pixel[2] === color.b &&\n    pixel[3] === 255 * color.a\n  );\n}\n\nexport function isPixel(a: Pixel, b: Pixel): boolean {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\nexport function getPixelOffset(\n  pos: Vec,\n  width: number,\n  height: number\n): number {\n  if (pos.y === 0) {\n    return pos.x * 4;\n  } else {\n    return pos.y * (width * 4) + pos.x * 4;\n  }\n}\n\nexport function getPixelFromOffset(\n  data: Uint8ClampedArray,\n  offset: number\n): Pixel {\n  return [data[offset], data[offset + 1], data[offset + 2], data[offset + 3]];\n}\n","import { createScene } from \"../engine/scenes/scene\";\nimport { startRuntime } from \"../engine/runtime\";\nimport { vec } from \"../engine/units/vec\";\nimport { camera, renderer, scenes, sprites } from \"../engine/global\";\nimport { createCursor } from \"./Cursor\";\nimport { GameState, PieceManager } from \"./global\";\n// @ts-ignore // TODO: cba\nimport * as sheet from \"./resources/sprites.png\";\n// @ts-ignore // TODO: cba\nimport * as sheetData from \"./resources/sprites.json\";\nimport { GRID_UNIT } from \"../engine/settings\";\nimport { createBoard } from \"./board/Board\";\nimport { createCalendar } from \"./calendar/calendar\";\nimport { getDefaultState } from \"./game-state/default-state\";\nimport * as fx from \"../engine/sprites/sprite-fx\";\n\nconst defaultScene = createScene(\"main\", 16, 16);\nconst cursor = createCursor();\n\nscenes.addScene(defaultScene);\ncamera.snapTo(vec(0, -260));\n// TODO: rethink the cursor... it shouldn't be added to the scenes grid as a child,\n//  it needs to be more \"global\" than that and survive resets\ndefaultScene.addGameObject(cursor);\n\nstartRuntime(\n  async (scene) => {\n    await sprites.loadSheet(\"puzzle\", sheet, sheetData);\n    let now = Date.now();\n    fx.createShadows();\n    console.log(\"create shadows: \", Date.now() - now, \"ms\");\n    now = Date.now();\n    fx.createOutlines();\n    console.log(\"create outlines: \", Date.now() - now, \"ms\");\n    now = Date.now();\n    fx.createHighlights();\n    console.log(\"create highlights: \", Date.now() - now, \"ms\");\n\n    PieceManager.start(scene.grid);\n\n    scene.addUIObject(\n      createCalendar(renderer.stage.width, GRID_UNIT * 3, new Date()),\n      vec(0, renderer.stage.height - GRID_UNIT * 3)\n    );\n\n    GameState.loadState(getDefaultState(scene.grid));\n\n    PieceManager.addBoardToGrid(\n      createBoard(\n        7,\n        7,\n        [vec(), vec(1, 0), vec(6, 0), vec(6, 1), vec(6, 2), vec(6, 3)],\n        [vec(1, 2), vec(4, 4)]\n      ),\n      vec(4, 4)\n    );\n  },\n  (delta) => {\n    GameState.update();\n  },\n  () => {},\n  () => {\n    PieceManager.debug();\n  }\n);\n","import { sprites } from \"../global\";\nimport { createCanvas } from \"../canvas\";\nimport { Sprite } from \"./sprites\";\nimport { vec, Vec } from \"../units/vec\";\nimport {\n  getPixelFromOffset,\n  getPixelOffset,\n  groupByRGB,\n  isColour,\n  isPixel,\n  isTransparent,\n  Pixel,\n  pixelsToGrid,\n} from \"../renderer/utils\";\nimport { clamp, max } from \"../maths\";\nimport { Color } from \"../color\";\n\nexport function createShadows(): void {\n  for (const sprite of sprites.getByPrefix(\"piece\")) {\n    const shadow = new Sprite(\n      sprite.getName() + \"_shadow\",\n      sprite.getWidth(),\n      sprite.getHeight()\n    );\n    for (const frame of sprite.getFrames()) {\n      const { img, height, width } = frame;\n      const cvs = createCanvas(width, height);\n      const { data } = img.getContext(\"2d\")!.getImageData(0, 0, width, height);\n      const newData = new Uint8ClampedArray(width * height * 4);\n      let offset = 0;\n      for (const pixel of groupByRGB([...data])) {\n        if (isTransparent(pixel)) {\n          newData.set([0], offset++);\n          newData.set([0], offset++);\n          newData.set([0], offset++);\n          newData.set([0], offset++);\n          continue;\n        }\n\n        newData.set([0], offset++);\n        newData.set([0], offset++);\n        newData.set([0], offset++);\n        newData.set([Math.round(255 / 2)], offset++);\n      }\n      cvs.ctx.putImageData(new ImageData(newData, width, height), 0, 0);\n      shadow.addFrame({\n        ...frame,\n        img: cvs.el,\n      });\n    }\n    sprites.addSprite(shadow);\n  }\n}\n\nexport function createOutlines(): void {\n  for (const sprite of sprites.getByPrefix(\"piece\")) {\n    if (sprite.getName().endsWith(\"_shadow\")) {\n      continue;\n    }\n\n    const outline = new Sprite(\n      sprite.getName() + \"_outline\",\n      sprite.getWidth(),\n      sprite.getHeight()\n    );\n    for (const frame of sprite.getFrames()) {\n      const { img, width, height } = frame;\n      const cvs = createCanvas(width, height);\n      const { data } = img.getContext(\"2d\")!.getImageData(0, 0, width, height);\n      const newData = new Uint8ClampedArray(width * height * 4);\n      newData.set(data, 0);\n\n      const shouldOutline = (pixel: Pixel): boolean => {\n        return !isTransparent(pixel) && !isColour(pixel, Color.white());\n      };\n\n      for (let x = 0; x < width; x++) {\n        for (let y = 0; y < height; y++) {\n          const o = getPixelOffset(vec(x, y), width, height);\n          const pixel: Pixel = [data[o], data[o + 1], data[o + 2], data[o + 3]];\n          const prev = getPixelFromOffset(\n            newData,\n            getPixelOffset(vec(clamp(x - 1, 0, width), y), width, height)\n          );\n\n          if (\n            (x === 0 && shouldOutline(pixel)) ||\n            (x === width - 1 && shouldOutline(pixel)) ||\n            (y === 0 && shouldOutline(pixel)) ||\n            (y === height - 1 && shouldOutline(pixel)) ||\n            (isTransparent(prev) && shouldOutline(pixel)) ||\n            (shouldOutline(prev) && isTransparent(pixel))\n          ) {\n            newData.set([255, 255, 255, 255], o);\n            newData.set([255, 255, 255, 255], o - 4);\n            newData.set([255, 255, 255, 255], o - 8);\n            newData.set([255, 255, 255, 255], o - 12);\n            newData.set([255, 255, 255, 255], o + 4);\n            newData.set([255, 255, 255, 255], o + 8);\n            newData.set([255, 255, 255, 255], o + 12);\n          }\n        }\n      }\n\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const o = getPixelOffset(vec(x, y), width, height);\n          const pixel: Pixel = [data[o], data[o + 1], data[o + 2], data[o + 3]];\n          const prev = getPixelFromOffset(\n            newData,\n            getPixelOffset(vec(x, clamp(y - 1, 0, height)), width, height)\n          );\n\n          if (\n            (x === 0 && shouldOutline(pixel)) ||\n            (x === width - 1 && shouldOutline(pixel)) ||\n            (y === 0 && shouldOutline(pixel)) ||\n            (y === height - 1 && shouldOutline(pixel)) ||\n            (isTransparent(prev) && shouldOutline(pixel)) ||\n            (shouldOutline(prev) && isTransparent(pixel))\n          ) {\n            newData.set([255, 255, 255, 255], o);\n          }\n        }\n      }\n\n      cvs.ctx.putImageData(new ImageData(newData, width, height), 0, 0);\n      outline.addFrame({ ...frame, img: cvs.el });\n    }\n\n    sprites.addSprite(outline);\n  }\n}\n\nexport function createHighlights(): void {\n  for (const sprite of sprites.getByPrefix(\"piece\")) {\n    if (sprite.getName().endsWith(\"_shadow\")) {\n      continue;\n    }\n\n    const highlight = new Sprite(\n      sprite.getName() + \"_highlight\",\n      sprite.getWidth(),\n      sprite.getHeight()\n    );\n    for (const frame of sprite.getFrames()) {\n      const { img, width, height } = frame;\n      const cvs = createCanvas(width, height);\n      const { data } = img.getContext(\"2d\")!.getImageData(0, 0, width, height);\n      const newData = new Uint8ClampedArray(width * height * 4);\n\n      newData.set(data, 0);\n\n      for (let x = 0; x < width; x++) {\n        for (let y = 0; y < height; y++) {\n          const offset = getPixelOffset(vec(x, y), width, height);\n          const pixel = getPixelFromOffset(newData, offset);\n\n          if (\n            isPixel(pixel, [24, 20, 37, 255]) // ||\n            // isPixel(pixel, [228, 166, 114, 255])\n          ) {\n            newData.set([255, 255, 255, 255], offset);\n          }\n        }\n      }\n\n      cvs.ctx.putImageData(new ImageData(newData, width, height), 0, 0);\n      highlight.addFrame({ ...frame, img: cvs.el });\n    }\n    sprites.addSprite(highlight);\n  }\n}\n","import { SerialisedGameState } from \"./GameState\";\nimport { pieceFactory } from \"../pieces/piece-factory\";\nimport { Grid } from \"../../engine/grid\";\nimport { Direction, vec } from \"../../engine/units/vec\";\n\nexport const getDefaultState = (grid: Grid): SerialisedGameState => {\n  const pieces = [\n    pieceFactory.get(\"piece_0\")(grid.localToWorld(vec(2, 11)), Direction.North),\n    pieceFactory.get(\"piece_1\")(grid.localToWorld(vec(7, 1)), Direction.East),\n    pieceFactory.get(\"piece_2\")(grid.localToWorld(vec(6, 12)), Direction.West),\n    pieceFactory.get(\"piece_3\")(grid.localToWorld(vec(11, 13)), Direction.East),\n    pieceFactory.get(\"piece_4\")(grid.localToWorld(vec(1, 1)), Direction.East),\n    pieceFactory.get(\"piece_5\")(grid.localToWorld(vec(0, 6)), Direction.South),\n    pieceFactory.get(\"piece_6\")(grid.localToWorld(vec(12, 7)), Direction.North),\n    pieceFactory.get(\"piece_7\")(grid.localToWorld(vec(12, 2)), Direction.East),\n  ];\n\n  pieces.forEach((p) => (p.parent = grid));\n\n  return {\n    pieces: pieces.map((p) => p.serialise()),\n  };\n};\n"],"names":["$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","parcelRequire","register","JSON","parse","$33adf0d0846a3a90$export$e66776c6fdb95d67","x","y","$33adf0d0846a3a90$export$35d863f4712b3c65","$33adf0d0846a3a90$export$da45c391d31222c4","$33adf0d0846a3a90$export$927940bf57d9a8c","$700df094141835be$export$202e0172ed3c7be0","$700df094141835be$export$e947a0f742cf021e","$700df094141835be$export$cacd6541cfeeb6c1","$22cfb376450aa934$export$573b9b62d5ae28f7","$22cfb376450aa934$export$2fe8f6b70a81ba43","constructor","static","from","toString","fixed","this","toFixed","equalsv","v","equals","add","addv","clone","sub","subv","divide","multiply","round","Math","mag","sqrt","normalize","distance","p","abs","dir","dest","start","end","progress","axis","s","e","north","North","east","East","south","South","west","West","a","b","find","$22cfb376450aa934$var$Pointer","pos","camera","state","Idle","isDown","downThisFrame","setScreenPos","vec","getWorldPos","getOffset","getScreenPos","$22cfb376450aa934$var$InputManager","stageOffset","keyDownThisFrame","keyWasDown","pointerWasDown","pointer","document","addEventListener","event","client","clientX","clientY","preventDefault","which","Primary","Secondary","key","values","includes","update","getKeyDownThisFrame","isPointerDownThisFrame","isPointerDown","debug","$798a05b6b23d0eb8$export$1c9f709888824e05","print","$0ca5f1cb725e9921$export$efa9a398d6368992","fmt","transport","console","warn","msg","write","now","Date","log","format","toISOString","str","f","replace","$ec2092522ab926b5$export$4923170e743afeed","window","innerWidth","$ec2092522ab926b5$export$c3d229d97039a2cb","innerHeight","$9d430b5c3be42ae9$export$955a2ebd2fb142ae","$9d430b5c3be42ae9$export$892596cec99bc70e","r","g","pixel","c","serialise","$ca52763cfa1d3401$export$f65ca476c09acec0","$05cc46d4d88b5d49$export$f80a6900d44a74ee","settings","getElementById","ctx","getContext","el","$05cc46d4d88b5d49$export$cd3d1f114b139967","width","height","cvs","createElement","imageSmoothingEnabled","$950dec47f5e6b05f$export$4b409e53cf4df6e6","w","h","$950dec47f5e6b05f$export$c79fc6492f3af13d","contains","n","o","$fef02c3cba54b3c1$export$13807d9ee5a34a42","$fef02c3cba54b3c1$export$cb6da89c6af1a8ec","$fef02c3cba54b3c1$export$2ddb90ad54e5f587","content","size","getRect","getPos","getWidthAndHeight","TopRight","BottomRight","Small","setContent","draw","$798a05b6b23d0eb8$export$e30378e28ad3e6ab","fillRect","black","fillText","$fef02c3cba54b3c1$export$d3cda41e44a6352b","white","$eee9d518e43f4e3a$export$51f76fced5d5614","entries","map","Map","set","k","get","has","$30e902f947b552f7$export$88530751e3977073","canvas","layers","queue","Set","bcr","getBoundingClientRect","stage","font","clear","clearRect","save","fillStyle","restore","camOffset","layer","color","originOffset","offset","wp","z","drawISoRect","fill","strokeWidth","beginPath","strokeStyle","lineWidth","moveTo","lineTo","closePath","stroke","strokeRect","text","maxWidth","newlineOffset","line","split","path","points","slice","renderSprite","tint","empty","alpha","frameIndex","sprite","$798a05b6b23d0eb8$export$72d98a059df66e6b","frame","getFrame","magenta","$ec2092522ab926b5$export$e9ebc946c2eaab9b","sp","getWidth","getHeight","img","globalAlpha","drawImage","call","q","calls","sort","sortedLayers","willDraw","$4cf918954b27adc0$export$7d15b64cf5a3a4c4","min","$4cf918954b27adc0$export$8960430cfd85939f","$04c621c8b217bc63$var$Debugger","padding","style","sampleCache","enqueue","dd","label","value","fn","sample","value1","transform","cache","lastSampleValue","v1","reduce","acc","$3a2be1b557fa1caa$export$1a5897aea388c2a1","colliders","willReadFrequently","addCollider","removeCollider","delete","getObjAt","p1","$798a05b6b23d0eb8$export$9d7c7e61b1dce3b0","objs","obj","getWorldPath","every","disable","isEnabled","getImageData","data","push","$af3fd2c1b2207993$export$79f141de891a5fed","renderer","pointerAnchor","posAnchor","snapTo","delta","$798a05b6b23d0eb8$export$b7e3ae3d7c15e42e","$ffd1c41b201510e7$export$3075603db8e6204c","name","frames","addFrame","max","getFrames","getFrameLen","getName","$ffd1c41b201510e7$var$spriteId","$ffd1c41b201510e7$export$1526a6c71c79d341","sprites","getByPrefix","prefix","startsWith","async","sheetPath","sheetData","sliceSheet","getSprites","applyScale","ox","oy","sheet","loadAsset","sliceSprite","addSprite","suffix","sRect","putImageData","debugSprite","dcvs","cloneNode","dctx","appendChild","red","Promise","res","rej","onerror","onload","sw","sh","setAttribute","src","$fd18142f5ce038e6$var$EventManager","listeners","eventsFired","listen","handler","handlers","newHandlers","remove","filter","hf","trigger","payload","listener","fired","l","$7d90a14654dff914$export$4b08aed5f1ec6952","panels","addPanel","panel","drawPanel","removePanel","$f66a940f0b469573$var$Notifications","notifications","$fef02c3cba54b3c1$export$71ce2d4d67b6d9e4","$798a05b6b23d0eb8$export$5525e5ba287fa6f5","createNotification","notification","created","join","$f8eab741ee1fd81a$var$SceneManger","scenes","activeScene","getActiveScene","addScene","scene","indexOf","zLayers","val","$30e902f947b552f7$export$53ae2f996c64e9a","$af3fd2c1b2207993$export$efd0f94c0736836b","$798a05b6b23d0eb8$export$656ad9fcb702b7a","left","top","$22cfb376450aa934$export$d3f50ec9ab1089ab","$798a05b6b23d0eb8$export$4bf9923669ad6c63","$798a05b6b23d0eb8$export$6008d97729a90c74","$798a05b6b23d0eb8$export$d7def349cabdd169","$cedd70217ba5cd3e$export$434da80b31429dcb","stateMachine","parent","children","collider","enabled","getState","getActiveState","enable","destroy","worldPos","setPos","hasChild","setChildren","getChildrenRecursive","getChildren","getParentsRecursive","parents","registerHandler","undefined","removeHandler","onPointerDown","onPointerUp","onPointerOver","onPointerOut","getGrid","err","$27c64b46bed5fe97$export$ef2184bd89960b14","$e04b76e49b42828f$export$d06866a9fb0606da","$27c64b46bed5fe97$var$id","factory","super","nodes","init","local","localToWorld","cartToIso","worldToLocalUnsafe","worldToLocalSnap","safe","isoToCart","world","getCenter","floor","cx","cy","forEach","cb","row","node","localPos","$10c05acd89edabbd$export$1f679544f90d7d7c","$41aa59a23ccc8d65$export$9c25f304ccafd1d0","$4bea5d94074b4b02$export$5eb8142d55bb2bc6","t","$4bea5d94074b4b02$export$a248d842d45c6f0b","$2c3da84ce4860c5e$export$7149c6ffc9994c32","$e04b76e49b42828f$export$70ae2c07e401031b","matrix","X","reverse","Y","$0a28511a5e9bddc7$export$7f987f14df204702","$ad974398f657926c$export$b6a79797ad180576","getPiece","child","$7a62a3e6e3c239cc$export$7de691058ff51291","piece","grid","$cd76140a7efd82f0$export$2160db08c2f12abd","cursorLocalPos","pieceLocalPos","setAnchor","cursorPos","resetHoverState","hovered","Rotate","rotate","Flip","flip","updateTempPlacement","canPlace","addPieceToGrid","animationOffset","isPuzzleComplete","alert","pieceOnGrid","getPieceAt","removePieceFromGrid","$7a62a3e6e3c239cc$var$id","$7a62a3e6e3c239cc$export$e6f974145d2c8955","anchor","rotation","pGrid","rows","occupied","$7a62a3e6e3c239cc$var$parse","shape","needsUpdate","rotateNodes","updatePiece","transposed","cols","result","j","newRow","$e04b76e49b42828f$export$9cb09a71b7d66923","range","mod","$4cf918954b27adc0$export$4997ffc0176396a6","getLocalPos","getNodes","isWithCursor","getAnchor","serialiseShape","$62dacd534b33bbf3$export$2160db08c2f12abd","pieceMatrix","pieces","board","debugTempPlacement","reset","getPieces","getBoard","addBoardToGrid","updateLocalRect","localPiecePos","getPieceLocalNodesAtLocalPos","solution","getSolutionNodes","freeNodes","isMatchingList","localPosWithAnchor","pieceNodes","isValidPlacement","$f4df98a8afcaf62d$export$fec3947133e3e4bb","$f4df98a8afcaf62d$var$registerPiece","green","$51ba92fc48adfaa4$var$GameState","savedState","Save","Load","loadState","saveState","getSaveStateKey","localStorage","setItem","stringify","getItem","$cd76140a7efd82f0$export$eb5ccdbd077479c","$b945fe596d5d9427$export$38af1803e3442a7f","ui","addGameObject","addUIObject","screenPos","dobj","u","getAllObjects","$d76e464aa326a8e2$export$b6a79797ad180576","pointerDown","$ec2092522ab926b5$export$a5c9d978e8ae4614","snapParent","hit","pop","$674834d33820a327$var$cursor","$674834d33820a327$var$Runtime","gameStart","gameUpdate","gameDraw","gameDebug","lastFrame","__scene","__pm","error","tick","remainingDelta","setTimeout","bind","remaining","$d8f30ef4a45ac1e7$exports","URL","resolve","import","meta","url","$54d03a5afbe6f845$exports","$f4b4c3c5d409881f$var$months","$f4b4c3c5d409881f$var$days","$f4b4c3c5d409881f$export$dc537a3a3893548e","localWidth","localHeight","invalidNodes","localRect","date","getMonth","getDate","invalidNodesLocal","some","$9391f88b552d3f0c$export$e029667a62135fd0","day","active","$9391f88b552d3f0c$export$99faa760c7908e4f","getTime","Width","Height","setActive","getDay","onClick","$bdce9d1873a749a3$var$getId","$bdce9d1873a749a3$export$9ca57ffea427d513","$bdce9d1873a749a3$export$75fa19aece944a5b","getDir","$e788f20efb3ead37$var$getDay","days","today","index","getFullYear","$e788f20efb3ead37$var$Calendar","activeDate","year","lastDay","complete","d","setDate","$e788f20efb3ead37$var$getDays","updateDays","Padding","updateDateByDir","isInside","getControlAtPos","getDaysToDraw","rangeWidth","lastPositiveDay","lastNegativeDay","getDrawableDayLength","unshift","$13f9bb31ae4a4428$export$d60e97b9f0082119","pixels","$13f9bb31ae4a4428$export$b5066e04f2f87723","$13f9bb31ae4a4428$export$9d8cf59fb9d186cc","$13f9bb31ae4a4428$export$c31dcd27bf18d652","$13f9bb31ae4a4428$export$1167cdf2aabe2968","$cc452e72caa88c74$var$defaultScene","$27c64b46bed5fe97$export$fce123c48a7b4eae","$b945fe596d5d9427$export$499f63eb5439a1d5","$cc452e72caa88c74$var$cursor","loadSheet","shadow","newData","Uint8ClampedArray","ImageData","$3e4aa4c41dda88a7$export$ed3f78685b9f13","endsWith","outline","shouldOutline","prev","y1","x1","$3e4aa4c41dda88a7$export$b35dfd66eaf77b75","highlight","$3e4aa4c41dda88a7$export$be36e179709c50d0","$99deeae24fb795da$export$a1659b54bac3252a"],"version":3,"file":"index.22798114.js.map"}